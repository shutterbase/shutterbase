// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/shutterbase/shutterbase/ent/apikey"
	"github.com/shutterbase/shutterbase/ent/batch"
	"github.com/shutterbase/shutterbase/ent/camera"
	"github.com/shutterbase/shutterbase/ent/image"
	"github.com/shutterbase/shutterbase/ent/imagetag"
	"github.com/shutterbase/shutterbase/ent/imagetagassignment"
	"github.com/shutterbase/shutterbase/ent/predicate"
	"github.com/shutterbase/shutterbase/ent/project"
	"github.com/shutterbase/shutterbase/ent/projectassignment"
	"github.com/shutterbase/shutterbase/ent/role"
	"github.com/shutterbase/shutterbase/ent/timeoffset"
	"github.com/shutterbase/shutterbase/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApiKey             = "ApiKey"
	TypeBatch              = "Batch"
	TypeCamera             = "Camera"
	TypeImage              = "Image"
	TypeImageTag           = "ImageTag"
	TypeImageTagAssignment = "ImageTagAssignment"
	TypeProject            = "Project"
	TypeProjectAssignment  = "ProjectAssignment"
	TypeRole               = "Role"
	TypeTimeOffset         = "TimeOffset"
	TypeUser               = "User"
)

// ApiKeyMutation represents an operation that mutates the ApiKey nodes in the graph.
type ApiKeyMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	key           *uuid.UUID
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ApiKey, error)
	predicates    []predicate.ApiKey
}

var _ ent.Mutation = (*ApiKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*ApiKeyMutation)

// newApiKeyMutation creates new mutation for the ApiKey entity.
func newApiKeyMutation(c config, op Op, opts ...apikeyOption) *ApiKeyMutation {
	m := &ApiKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeApiKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiKeyID sets the ID field of the mutation.
func withApiKeyID(id uuid.UUID) apikeyOption {
	return func(m *ApiKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiKey
		)
		m.oldValue = func(ctx context.Context) (*ApiKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiKey sets the old ApiKey of the mutation.
func withApiKey(node *ApiKey) apikeyOption {
	return func(m *ApiKeyMutation) {
		m.oldValue = func(context.Context) (*ApiKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiKey entities.
func (m *ApiKeyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiKeyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiKeyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "key" field.
func (m *ApiKeyMutation) SetKey(u uuid.UUID) {
	m.key = &u
}

// Key returns the value of the "key" field in the mutation.
func (m *ApiKeyMutation) Key() (r uuid.UUID, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldKey(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ApiKeyMutation) ResetKey() {
	m.key = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ApiKeyMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApiKeyMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApiKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ApiKeyMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApiKeyMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApiKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ApiKeyMutation builder.
func (m *ApiKeyMutation) Where(ps ...predicate.ApiKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiKey).
func (m *ApiKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiKeyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldKey:
		return m.Key()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	}
	return nil, fmt.Errorf("unknown ApiKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiKeyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiKeyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ApiKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ApiKey edge %s", name)
}

// BatchMutation represents an operation that mutates the Batch nodes in the graph.
type BatchMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	clearedFields     map[string]struct{}
	images            map[uuid.UUID]struct{}
	removedimages     map[uuid.UUID]struct{}
	clearedimages     bool
	project           *uuid.UUID
	clearedproject    bool
	created_by        *uuid.UUID
	clearedcreated_by bool
	updated_by        *uuid.UUID
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*Batch, error)
	predicates        []predicate.Batch
}

var _ ent.Mutation = (*BatchMutation)(nil)

// batchOption allows management of the mutation configuration using functional options.
type batchOption func(*BatchMutation)

// newBatchMutation creates new mutation for the Batch entity.
func newBatchMutation(c config, op Op, opts ...batchOption) *BatchMutation {
	m := &BatchMutation{
		config:        c,
		op:            op,
		typ:           TypeBatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBatchID sets the ID field of the mutation.
func withBatchID(id uuid.UUID) batchOption {
	return func(m *BatchMutation) {
		var (
			err   error
			once  sync.Once
			value *Batch
		)
		m.oldValue = func(ctx context.Context) (*Batch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Batch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBatch sets the old Batch of the mutation.
func withBatch(node *Batch) batchOption {
	return func(m *BatchMutation) {
		m.oldValue = func(context.Context) (*Batch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Batch entities.
func (m *BatchMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BatchMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BatchMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Batch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BatchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BatchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Batch entity.
// If the Batch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BatchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BatchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BatchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Batch entity.
// If the Batch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BatchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *BatchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BatchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Batch entity.
// If the Batch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BatchMutation) ResetName() {
	m.name = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *BatchMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *BatchMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *BatchMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *BatchMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *BatchMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *BatchMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *BatchMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *BatchMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *BatchMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *BatchMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *BatchMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *BatchMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *BatchMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *BatchMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *BatchMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *BatchMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *BatchMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *BatchMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *BatchMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *BatchMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *BatchMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *BatchMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *BatchMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *BatchMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *BatchMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the BatchMutation builder.
func (m *BatchMutation) Where(ps ...predicate.Batch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Batch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Batch).
func (m *BatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BatchMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, batch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, batch.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, batch.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case batch.FieldCreatedAt:
		return m.CreatedAt()
	case batch.FieldUpdatedAt:
		return m.UpdatedAt()
	case batch.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case batch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case batch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case batch.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Batch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case batch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case batch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case batch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Batch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BatchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BatchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Batch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BatchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BatchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Batch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BatchMutation) ResetField(name string) error {
	switch name {
	case batch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case batch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case batch.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Batch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.images != nil {
		edges = append(edges, batch.EdgeImages)
	}
	if m.project != nil {
		edges = append(edges, batch.EdgeProject)
	}
	if m.created_by != nil {
		edges = append(edges, batch.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, batch.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case batch.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case batch.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case batch.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case batch.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedimages != nil {
		edges = append(edges, batch.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case batch.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedimages {
		edges = append(edges, batch.EdgeImages)
	}
	if m.clearedproject {
		edges = append(edges, batch.EdgeProject)
	}
	if m.clearedcreated_by {
		edges = append(edges, batch.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, batch.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BatchMutation) EdgeCleared(name string) bool {
	switch name {
	case batch.EdgeImages:
		return m.clearedimages
	case batch.EdgeProject:
		return m.clearedproject
	case batch.EdgeCreatedBy:
		return m.clearedcreated_by
	case batch.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BatchMutation) ClearEdge(name string) error {
	switch name {
	case batch.EdgeProject:
		m.ClearProject()
		return nil
	case batch.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case batch.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Batch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BatchMutation) ResetEdge(name string) error {
	switch name {
	case batch.EdgeImages:
		m.ResetImages()
		return nil
	case batch.EdgeProject:
		m.ResetProject()
		return nil
	case batch.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case batch.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Batch edge %s", name)
}

// CameraMutation represents an operation that mutates the Camera nodes in the graph.
type CameraMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	description        *string
	clearedFields      map[string]struct{}
	timeOffsets        map[uuid.UUID]struct{}
	removedtimeOffsets map[uuid.UUID]struct{}
	clearedtimeOffsets bool
	images             map[uuid.UUID]struct{}
	removedimages      map[uuid.UUID]struct{}
	clearedimages      bool
	owner              *uuid.UUID
	clearedowner       bool
	created_by         *uuid.UUID
	clearedcreated_by  bool
	updated_by         *uuid.UUID
	clearedupdated_by  bool
	done               bool
	oldValue           func(context.Context) (*Camera, error)
	predicates         []predicate.Camera
}

var _ ent.Mutation = (*CameraMutation)(nil)

// cameraOption allows management of the mutation configuration using functional options.
type cameraOption func(*CameraMutation)

// newCameraMutation creates new mutation for the Camera entity.
func newCameraMutation(c config, op Op, opts ...cameraOption) *CameraMutation {
	m := &CameraMutation{
		config:        c,
		op:            op,
		typ:           TypeCamera,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCameraID sets the ID field of the mutation.
func withCameraID(id uuid.UUID) cameraOption {
	return func(m *CameraMutation) {
		var (
			err   error
			once  sync.Once
			value *Camera
		)
		m.oldValue = func(ctx context.Context) (*Camera, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Camera.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCamera sets the old Camera of the mutation.
func withCamera(node *Camera) cameraOption {
	return func(m *CameraMutation) {
		m.oldValue = func(context.Context) (*Camera, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CameraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CameraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Camera entities.
func (m *CameraMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CameraMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CameraMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Camera.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CameraMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CameraMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CameraMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CameraMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CameraMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CameraMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CameraMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CameraMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CameraMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CameraMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CameraMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CameraMutation) ResetDescription() {
	m.description = nil
}

// AddTimeOffsetIDs adds the "timeOffsets" edge to the TimeOffset entity by ids.
func (m *CameraMutation) AddTimeOffsetIDs(ids ...uuid.UUID) {
	if m.timeOffsets == nil {
		m.timeOffsets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.timeOffsets[ids[i]] = struct{}{}
	}
}

// ClearTimeOffsets clears the "timeOffsets" edge to the TimeOffset entity.
func (m *CameraMutation) ClearTimeOffsets() {
	m.clearedtimeOffsets = true
}

// TimeOffsetsCleared reports if the "timeOffsets" edge to the TimeOffset entity was cleared.
func (m *CameraMutation) TimeOffsetsCleared() bool {
	return m.clearedtimeOffsets
}

// RemoveTimeOffsetIDs removes the "timeOffsets" edge to the TimeOffset entity by IDs.
func (m *CameraMutation) RemoveTimeOffsetIDs(ids ...uuid.UUID) {
	if m.removedtimeOffsets == nil {
		m.removedtimeOffsets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.timeOffsets, ids[i])
		m.removedtimeOffsets[ids[i]] = struct{}{}
	}
}

// RemovedTimeOffsets returns the removed IDs of the "timeOffsets" edge to the TimeOffset entity.
func (m *CameraMutation) RemovedTimeOffsetsIDs() (ids []uuid.UUID) {
	for id := range m.removedtimeOffsets {
		ids = append(ids, id)
	}
	return
}

// TimeOffsetsIDs returns the "timeOffsets" edge IDs in the mutation.
func (m *CameraMutation) TimeOffsetsIDs() (ids []uuid.UUID) {
	for id := range m.timeOffsets {
		ids = append(ids, id)
	}
	return
}

// ResetTimeOffsets resets all changes to the "timeOffsets" edge.
func (m *CameraMutation) ResetTimeOffsets() {
	m.timeOffsets = nil
	m.clearedtimeOffsets = false
	m.removedtimeOffsets = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *CameraMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *CameraMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *CameraMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *CameraMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *CameraMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *CameraMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *CameraMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CameraMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CameraMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CameraMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CameraMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CameraMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CameraMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *CameraMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *CameraMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *CameraMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *CameraMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *CameraMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *CameraMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *CameraMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *CameraMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *CameraMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *CameraMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *CameraMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *CameraMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the CameraMutation builder.
func (m *CameraMutation) Where(ps ...predicate.Camera) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CameraMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CameraMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Camera, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CameraMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CameraMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Camera).
func (m *CameraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CameraMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, camera.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, camera.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, camera.FieldName)
	}
	if m.description != nil {
		fields = append(fields, camera.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CameraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case camera.FieldCreatedAt:
		return m.CreatedAt()
	case camera.FieldUpdatedAt:
		return m.UpdatedAt()
	case camera.FieldName:
		return m.Name()
	case camera.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CameraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case camera.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case camera.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case camera.FieldName:
		return m.OldName(ctx)
	case camera.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Camera field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case camera.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case camera.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case camera.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case camera.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CameraMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CameraMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Camera numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CameraMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CameraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CameraMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Camera nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CameraMutation) ResetField(name string) error {
	switch name {
	case camera.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case camera.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case camera.FieldName:
		m.ResetName()
		return nil
	case camera.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CameraMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.timeOffsets != nil {
		edges = append(edges, camera.EdgeTimeOffsets)
	}
	if m.images != nil {
		edges = append(edges, camera.EdgeImages)
	}
	if m.owner != nil {
		edges = append(edges, camera.EdgeOwner)
	}
	if m.created_by != nil {
		edges = append(edges, camera.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, camera.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CameraMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeTimeOffsets:
		ids := make([]ent.Value, 0, len(m.timeOffsets))
		for id := range m.timeOffsets {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case camera.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case camera.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CameraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtimeOffsets != nil {
		edges = append(edges, camera.EdgeTimeOffsets)
	}
	if m.removedimages != nil {
		edges = append(edges, camera.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CameraMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeTimeOffsets:
		ids := make([]ent.Value, 0, len(m.removedtimeOffsets))
		for id := range m.removedtimeOffsets {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CameraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtimeOffsets {
		edges = append(edges, camera.EdgeTimeOffsets)
	}
	if m.clearedimages {
		edges = append(edges, camera.EdgeImages)
	}
	if m.clearedowner {
		edges = append(edges, camera.EdgeOwner)
	}
	if m.clearedcreated_by {
		edges = append(edges, camera.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, camera.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CameraMutation) EdgeCleared(name string) bool {
	switch name {
	case camera.EdgeTimeOffsets:
		return m.clearedtimeOffsets
	case camera.EdgeImages:
		return m.clearedimages
	case camera.EdgeOwner:
		return m.clearedowner
	case camera.EdgeCreatedBy:
		return m.clearedcreated_by
	case camera.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CameraMutation) ClearEdge(name string) error {
	switch name {
	case camera.EdgeOwner:
		m.ClearOwner()
		return nil
	case camera.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case camera.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Camera unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CameraMutation) ResetEdge(name string) error {
	switch name {
	case camera.EdgeTimeOffsets:
		m.ResetTimeOffsets()
		return nil
	case camera.EdgeImages:
		m.ResetImages()
		return nil
	case camera.EdgeOwner:
		m.ResetOwner()
		return nil
	case camera.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case camera.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Camera edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	thumbnail_id                 *uuid.UUID
	file_name                    *string
	computed_file_name           *string
	description                  *string
	exif_data                    *map[string]interface{}
	captured_at                  *time.Time
	captured_at_corrected        *time.Time
	inferred_at                  *time.Time
	clearedFields                map[string]struct{}
	image_tag_assignments        map[uuid.UUID]struct{}
	removedimage_tag_assignments map[uuid.UUID]struct{}
	clearedimage_tag_assignments bool
	user                         *uuid.UUID
	cleareduser                  bool
	batch                        *uuid.UUID
	clearedbatch                 bool
	project                      *uuid.UUID
	clearedproject               bool
	camera                       *uuid.UUID
	clearedcamera                bool
	created_by                   *uuid.UUID
	clearedcreated_by            bool
	updated_by                   *uuid.UUID
	clearedupdated_by            bool
	done                         bool
	oldValue                     func(context.Context) (*Image, error)
	predicates                   []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id uuid.UUID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetThumbnailID sets the "thumbnail_id" field.
func (m *ImageMutation) SetThumbnailID(u uuid.UUID) {
	m.thumbnail_id = &u
}

// ThumbnailID returns the value of the "thumbnail_id" field in the mutation.
func (m *ImageMutation) ThumbnailID() (r uuid.UUID, exists bool) {
	v := m.thumbnail_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailID returns the old "thumbnail_id" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldThumbnailID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailID: %w", err)
	}
	return oldValue.ThumbnailID, nil
}

// ClearThumbnailID clears the value of the "thumbnail_id" field.
func (m *ImageMutation) ClearThumbnailID() {
	m.thumbnail_id = nil
	m.clearedFields[image.FieldThumbnailID] = struct{}{}
}

// ThumbnailIDCleared returns if the "thumbnail_id" field was cleared in this mutation.
func (m *ImageMutation) ThumbnailIDCleared() bool {
	_, ok := m.clearedFields[image.FieldThumbnailID]
	return ok
}

// ResetThumbnailID resets all changes to the "thumbnail_id" field.
func (m *ImageMutation) ResetThumbnailID() {
	m.thumbnail_id = nil
	delete(m.clearedFields, image.FieldThumbnailID)
}

// SetFileName sets the "file_name" field.
func (m *ImageMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *ImageMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *ImageMutation) ResetFileName() {
	m.file_name = nil
}

// SetComputedFileName sets the "computed_file_name" field.
func (m *ImageMutation) SetComputedFileName(s string) {
	m.computed_file_name = &s
}

// ComputedFileName returns the value of the "computed_file_name" field in the mutation.
func (m *ImageMutation) ComputedFileName() (r string, exists bool) {
	v := m.computed_file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldComputedFileName returns the old "computed_file_name" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldComputedFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComputedFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComputedFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComputedFileName: %w", err)
	}
	return oldValue.ComputedFileName, nil
}

// ResetComputedFileName resets all changes to the "computed_file_name" field.
func (m *ImageMutation) ResetComputedFileName() {
	m.computed_file_name = nil
}

// SetDescription sets the "description" field.
func (m *ImageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ImageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ImageMutation) ResetDescription() {
	m.description = nil
}

// SetExifData sets the "exif_data" field.
func (m *ImageMutation) SetExifData(value map[string]interface{}) {
	m.exif_data = &value
}

// ExifData returns the value of the "exif_data" field in the mutation.
func (m *ImageMutation) ExifData() (r map[string]interface{}, exists bool) {
	v := m.exif_data
	if v == nil {
		return
	}
	return *v, true
}

// OldExifData returns the old "exif_data" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldExifData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExifData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExifData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExifData: %w", err)
	}
	return oldValue.ExifData, nil
}

// ResetExifData resets all changes to the "exif_data" field.
func (m *ImageMutation) ResetExifData() {
	m.exif_data = nil
}

// SetCapturedAt sets the "captured_at" field.
func (m *ImageMutation) SetCapturedAt(t time.Time) {
	m.captured_at = &t
}

// CapturedAt returns the value of the "captured_at" field in the mutation.
func (m *ImageMutation) CapturedAt() (r time.Time, exists bool) {
	v := m.captured_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCapturedAt returns the old "captured_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCapturedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapturedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapturedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapturedAt: %w", err)
	}
	return oldValue.CapturedAt, nil
}

// ClearCapturedAt clears the value of the "captured_at" field.
func (m *ImageMutation) ClearCapturedAt() {
	m.captured_at = nil
	m.clearedFields[image.FieldCapturedAt] = struct{}{}
}

// CapturedAtCleared returns if the "captured_at" field was cleared in this mutation.
func (m *ImageMutation) CapturedAtCleared() bool {
	_, ok := m.clearedFields[image.FieldCapturedAt]
	return ok
}

// ResetCapturedAt resets all changes to the "captured_at" field.
func (m *ImageMutation) ResetCapturedAt() {
	m.captured_at = nil
	delete(m.clearedFields, image.FieldCapturedAt)
}

// SetCapturedAtCorrected sets the "captured_at_corrected" field.
func (m *ImageMutation) SetCapturedAtCorrected(t time.Time) {
	m.captured_at_corrected = &t
}

// CapturedAtCorrected returns the value of the "captured_at_corrected" field in the mutation.
func (m *ImageMutation) CapturedAtCorrected() (r time.Time, exists bool) {
	v := m.captured_at_corrected
	if v == nil {
		return
	}
	return *v, true
}

// OldCapturedAtCorrected returns the old "captured_at_corrected" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCapturedAtCorrected(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapturedAtCorrected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapturedAtCorrected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapturedAtCorrected: %w", err)
	}
	return oldValue.CapturedAtCorrected, nil
}

// ClearCapturedAtCorrected clears the value of the "captured_at_corrected" field.
func (m *ImageMutation) ClearCapturedAtCorrected() {
	m.captured_at_corrected = nil
	m.clearedFields[image.FieldCapturedAtCorrected] = struct{}{}
}

// CapturedAtCorrectedCleared returns if the "captured_at_corrected" field was cleared in this mutation.
func (m *ImageMutation) CapturedAtCorrectedCleared() bool {
	_, ok := m.clearedFields[image.FieldCapturedAtCorrected]
	return ok
}

// ResetCapturedAtCorrected resets all changes to the "captured_at_corrected" field.
func (m *ImageMutation) ResetCapturedAtCorrected() {
	m.captured_at_corrected = nil
	delete(m.clearedFields, image.FieldCapturedAtCorrected)
}

// SetInferredAt sets the "inferred_at" field.
func (m *ImageMutation) SetInferredAt(t time.Time) {
	m.inferred_at = &t
}

// InferredAt returns the value of the "inferred_at" field in the mutation.
func (m *ImageMutation) InferredAt() (r time.Time, exists bool) {
	v := m.inferred_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInferredAt returns the old "inferred_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldInferredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInferredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInferredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInferredAt: %w", err)
	}
	return oldValue.InferredAt, nil
}

// ClearInferredAt clears the value of the "inferred_at" field.
func (m *ImageMutation) ClearInferredAt() {
	m.inferred_at = nil
	m.clearedFields[image.FieldInferredAt] = struct{}{}
}

// InferredAtCleared returns if the "inferred_at" field was cleared in this mutation.
func (m *ImageMutation) InferredAtCleared() bool {
	_, ok := m.clearedFields[image.FieldInferredAt]
	return ok
}

// ResetInferredAt resets all changes to the "inferred_at" field.
func (m *ImageMutation) ResetInferredAt() {
	m.inferred_at = nil
	delete(m.clearedFields, image.FieldInferredAt)
}

// AddImageTagAssignmentIDs adds the "image_tag_assignments" edge to the ImageTagAssignment entity by ids.
func (m *ImageMutation) AddImageTagAssignmentIDs(ids ...uuid.UUID) {
	if m.image_tag_assignments == nil {
		m.image_tag_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.image_tag_assignments[ids[i]] = struct{}{}
	}
}

// ClearImageTagAssignments clears the "image_tag_assignments" edge to the ImageTagAssignment entity.
func (m *ImageMutation) ClearImageTagAssignments() {
	m.clearedimage_tag_assignments = true
}

// ImageTagAssignmentsCleared reports if the "image_tag_assignments" edge to the ImageTagAssignment entity was cleared.
func (m *ImageMutation) ImageTagAssignmentsCleared() bool {
	return m.clearedimage_tag_assignments
}

// RemoveImageTagAssignmentIDs removes the "image_tag_assignments" edge to the ImageTagAssignment entity by IDs.
func (m *ImageMutation) RemoveImageTagAssignmentIDs(ids ...uuid.UUID) {
	if m.removedimage_tag_assignments == nil {
		m.removedimage_tag_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.image_tag_assignments, ids[i])
		m.removedimage_tag_assignments[ids[i]] = struct{}{}
	}
}

// RemovedImageTagAssignments returns the removed IDs of the "image_tag_assignments" edge to the ImageTagAssignment entity.
func (m *ImageMutation) RemovedImageTagAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedimage_tag_assignments {
		ids = append(ids, id)
	}
	return
}

// ImageTagAssignmentsIDs returns the "image_tag_assignments" edge IDs in the mutation.
func (m *ImageMutation) ImageTagAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.image_tag_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetImageTagAssignments resets all changes to the "image_tag_assignments" edge.
func (m *ImageMutation) ResetImageTagAssignments() {
	m.image_tag_assignments = nil
	m.clearedimage_tag_assignments = false
	m.removedimage_tag_assignments = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ImageMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ImageMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ImageMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ImageMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ImageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBatchID sets the "batch" edge to the Batch entity by id.
func (m *ImageMutation) SetBatchID(id uuid.UUID) {
	m.batch = &id
}

// ClearBatch clears the "batch" edge to the Batch entity.
func (m *ImageMutation) ClearBatch() {
	m.clearedbatch = true
}

// BatchCleared reports if the "batch" edge to the Batch entity was cleared.
func (m *ImageMutation) BatchCleared() bool {
	return m.clearedbatch
}

// BatchID returns the "batch" edge ID in the mutation.
func (m *ImageMutation) BatchID() (id uuid.UUID, exists bool) {
	if m.batch != nil {
		return *m.batch, true
	}
	return
}

// BatchIDs returns the "batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatchID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) BatchIDs() (ids []uuid.UUID) {
	if id := m.batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBatch resets all changes to the "batch" edge.
func (m *ImageMutation) ResetBatch() {
	m.batch = nil
	m.clearedbatch = false
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ImageMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ImageMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ImageMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ImageMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ImageMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetCameraID sets the "camera" edge to the Camera entity by id.
func (m *ImageMutation) SetCameraID(id uuid.UUID) {
	m.camera = &id
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *ImageMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *ImageMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraID returns the "camera" edge ID in the mutation.
func (m *ImageMutation) CameraID() (id uuid.UUID, exists bool) {
	if m.camera != nil {
		return *m.camera, true
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) CameraIDs() (ids []uuid.UUID) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *ImageMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ImageMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ImageMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ImageMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ImageMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ImageMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ImageMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ImageMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ImageMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ImageMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ImageMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, image.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, image.FieldUpdatedAt)
	}
	if m.thumbnail_id != nil {
		fields = append(fields, image.FieldThumbnailID)
	}
	if m.file_name != nil {
		fields = append(fields, image.FieldFileName)
	}
	if m.computed_file_name != nil {
		fields = append(fields, image.FieldComputedFileName)
	}
	if m.description != nil {
		fields = append(fields, image.FieldDescription)
	}
	if m.exif_data != nil {
		fields = append(fields, image.FieldExifData)
	}
	if m.captured_at != nil {
		fields = append(fields, image.FieldCapturedAt)
	}
	if m.captured_at_corrected != nil {
		fields = append(fields, image.FieldCapturedAtCorrected)
	}
	if m.inferred_at != nil {
		fields = append(fields, image.FieldInferredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldCreatedAt:
		return m.CreatedAt()
	case image.FieldUpdatedAt:
		return m.UpdatedAt()
	case image.FieldThumbnailID:
		return m.ThumbnailID()
	case image.FieldFileName:
		return m.FileName()
	case image.FieldComputedFileName:
		return m.ComputedFileName()
	case image.FieldDescription:
		return m.Description()
	case image.FieldExifData:
		return m.ExifData()
	case image.FieldCapturedAt:
		return m.CapturedAt()
	case image.FieldCapturedAtCorrected:
		return m.CapturedAtCorrected()
	case image.FieldInferredAt:
		return m.InferredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case image.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case image.FieldThumbnailID:
		return m.OldThumbnailID(ctx)
	case image.FieldFileName:
		return m.OldFileName(ctx)
	case image.FieldComputedFileName:
		return m.OldComputedFileName(ctx)
	case image.FieldDescription:
		return m.OldDescription(ctx)
	case image.FieldExifData:
		return m.OldExifData(ctx)
	case image.FieldCapturedAt:
		return m.OldCapturedAt(ctx)
	case image.FieldCapturedAtCorrected:
		return m.OldCapturedAtCorrected(ctx)
	case image.FieldInferredAt:
		return m.OldInferredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case image.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case image.FieldThumbnailID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailID(v)
		return nil
	case image.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case image.FieldComputedFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComputedFileName(v)
		return nil
	case image.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case image.FieldExifData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExifData(v)
		return nil
	case image.FieldCapturedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapturedAt(v)
		return nil
	case image.FieldCapturedAtCorrected:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapturedAtCorrected(v)
		return nil
	case image.FieldInferredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInferredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(image.FieldThumbnailID) {
		fields = append(fields, image.FieldThumbnailID)
	}
	if m.FieldCleared(image.FieldCapturedAt) {
		fields = append(fields, image.FieldCapturedAt)
	}
	if m.FieldCleared(image.FieldCapturedAtCorrected) {
		fields = append(fields, image.FieldCapturedAtCorrected)
	}
	if m.FieldCleared(image.FieldInferredAt) {
		fields = append(fields, image.FieldInferredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	switch name {
	case image.FieldThumbnailID:
		m.ClearThumbnailID()
		return nil
	case image.FieldCapturedAt:
		m.ClearCapturedAt()
		return nil
	case image.FieldCapturedAtCorrected:
		m.ClearCapturedAtCorrected()
		return nil
	case image.FieldInferredAt:
		m.ClearInferredAt()
		return nil
	}
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case image.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case image.FieldThumbnailID:
		m.ResetThumbnailID()
		return nil
	case image.FieldFileName:
		m.ResetFileName()
		return nil
	case image.FieldComputedFileName:
		m.ResetComputedFileName()
		return nil
	case image.FieldDescription:
		m.ResetDescription()
		return nil
	case image.FieldExifData:
		m.ResetExifData()
		return nil
	case image.FieldCapturedAt:
		m.ResetCapturedAt()
		return nil
	case image.FieldCapturedAtCorrected:
		m.ResetCapturedAtCorrected()
		return nil
	case image.FieldInferredAt:
		m.ResetInferredAt()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.image_tag_assignments != nil {
		edges = append(edges, image.EdgeImageTagAssignments)
	}
	if m.user != nil {
		edges = append(edges, image.EdgeUser)
	}
	if m.batch != nil {
		edges = append(edges, image.EdgeBatch)
	}
	if m.project != nil {
		edges = append(edges, image.EdgeProject)
	}
	if m.camera != nil {
		edges = append(edges, image.EdgeCamera)
	}
	if m.created_by != nil {
		edges = append(edges, image.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, image.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeImageTagAssignments:
		ids := make([]ent.Value, 0, len(m.image_tag_assignments))
		for id := range m.image_tag_assignments {
			ids = append(ids, id)
		}
		return ids
	case image.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeBatch:
		if id := m.batch; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedimage_tag_assignments != nil {
		edges = append(edges, image.EdgeImageTagAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeImageTagAssignments:
		ids := make([]ent.Value, 0, len(m.removedimage_tag_assignments))
		for id := range m.removedimage_tag_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedimage_tag_assignments {
		edges = append(edges, image.EdgeImageTagAssignments)
	}
	if m.cleareduser {
		edges = append(edges, image.EdgeUser)
	}
	if m.clearedbatch {
		edges = append(edges, image.EdgeBatch)
	}
	if m.clearedproject {
		edges = append(edges, image.EdgeProject)
	}
	if m.clearedcamera {
		edges = append(edges, image.EdgeCamera)
	}
	if m.clearedcreated_by {
		edges = append(edges, image.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, image.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeImageTagAssignments:
		return m.clearedimage_tag_assignments
	case image.EdgeUser:
		return m.cleareduser
	case image.EdgeBatch:
		return m.clearedbatch
	case image.EdgeProject:
		return m.clearedproject
	case image.EdgeCamera:
		return m.clearedcamera
	case image.EdgeCreatedBy:
		return m.clearedcreated_by
	case image.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeUser:
		m.ClearUser()
		return nil
	case image.EdgeBatch:
		m.ClearBatch()
		return nil
	case image.EdgeProject:
		m.ClearProject()
		return nil
	case image.EdgeCamera:
		m.ClearCamera()
		return nil
	case image.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case image.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeImageTagAssignments:
		m.ResetImageTagAssignments()
		return nil
	case image.EdgeUser:
		m.ResetUser()
		return nil
	case image.EdgeBatch:
		m.ResetBatch()
		return nil
	case image.EdgeProject:
		m.ResetProject()
		return nil
	case image.EdgeCamera:
		m.ResetCamera()
		return nil
	case image.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case image.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// ImageTagMutation represents an operation that mutates the ImageTag nodes in the graph.
type ImageTagMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	name                         *string
	description                  *string
	is_album                     *bool
	_type                        *imagetag.Type
	clearedFields                map[string]struct{}
	project                      *uuid.UUID
	clearedproject               bool
	image_tag_assignments        map[uuid.UUID]struct{}
	removedimage_tag_assignments map[uuid.UUID]struct{}
	clearedimage_tag_assignments bool
	created_by                   *uuid.UUID
	clearedcreated_by            bool
	updated_by                   *uuid.UUID
	clearedupdated_by            bool
	done                         bool
	oldValue                     func(context.Context) (*ImageTag, error)
	predicates                   []predicate.ImageTag
}

var _ ent.Mutation = (*ImageTagMutation)(nil)

// imagetagOption allows management of the mutation configuration using functional options.
type imagetagOption func(*ImageTagMutation)

// newImageTagMutation creates new mutation for the ImageTag entity.
func newImageTagMutation(c config, op Op, opts ...imagetagOption) *ImageTagMutation {
	m := &ImageTagMutation{
		config:        c,
		op:            op,
		typ:           TypeImageTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageTagID sets the ID field of the mutation.
func withImageTagID(id uuid.UUID) imagetagOption {
	return func(m *ImageTagMutation) {
		var (
			err   error
			once  sync.Once
			value *ImageTag
		)
		m.oldValue = func(ctx context.Context) (*ImageTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImageTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImageTag sets the old ImageTag of the mutation.
func withImageTag(node *ImageTag) imagetagOption {
	return func(m *ImageTagMutation) {
		m.oldValue = func(context.Context) (*ImageTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ImageTag entities.
func (m *ImageTagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageTagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageTagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImageTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ImageTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImageTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImageTagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ImageTagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ImageTagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ImageTagMutation) ResetDescription() {
	m.description = nil
}

// SetIsAlbum sets the "is_album" field.
func (m *ImageTagMutation) SetIsAlbum(b bool) {
	m.is_album = &b
}

// IsAlbum returns the value of the "is_album" field in the mutation.
func (m *ImageTagMutation) IsAlbum() (r bool, exists bool) {
	v := m.is_album
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAlbum returns the old "is_album" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldIsAlbum(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAlbum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAlbum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAlbum: %w", err)
	}
	return oldValue.IsAlbum, nil
}

// ResetIsAlbum resets all changes to the "is_album" field.
func (m *ImageTagMutation) ResetIsAlbum() {
	m.is_album = nil
}

// SetType sets the "type" field.
func (m *ImageTagMutation) SetType(i imagetag.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ImageTagMutation) GetType() (r imagetag.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldType(ctx context.Context) (v imagetag.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ImageTagMutation) ResetType() {
	m._type = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ImageTagMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ImageTagMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ImageTagMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ImageTagMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ImageTagMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ImageTagMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddImageTagAssignmentIDs adds the "image_tag_assignments" edge to the ImageTagAssignment entity by ids.
func (m *ImageTagMutation) AddImageTagAssignmentIDs(ids ...uuid.UUID) {
	if m.image_tag_assignments == nil {
		m.image_tag_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.image_tag_assignments[ids[i]] = struct{}{}
	}
}

// ClearImageTagAssignments clears the "image_tag_assignments" edge to the ImageTagAssignment entity.
func (m *ImageTagMutation) ClearImageTagAssignments() {
	m.clearedimage_tag_assignments = true
}

// ImageTagAssignmentsCleared reports if the "image_tag_assignments" edge to the ImageTagAssignment entity was cleared.
func (m *ImageTagMutation) ImageTagAssignmentsCleared() bool {
	return m.clearedimage_tag_assignments
}

// RemoveImageTagAssignmentIDs removes the "image_tag_assignments" edge to the ImageTagAssignment entity by IDs.
func (m *ImageTagMutation) RemoveImageTagAssignmentIDs(ids ...uuid.UUID) {
	if m.removedimage_tag_assignments == nil {
		m.removedimage_tag_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.image_tag_assignments, ids[i])
		m.removedimage_tag_assignments[ids[i]] = struct{}{}
	}
}

// RemovedImageTagAssignments returns the removed IDs of the "image_tag_assignments" edge to the ImageTagAssignment entity.
func (m *ImageTagMutation) RemovedImageTagAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedimage_tag_assignments {
		ids = append(ids, id)
	}
	return
}

// ImageTagAssignmentsIDs returns the "image_tag_assignments" edge IDs in the mutation.
func (m *ImageTagMutation) ImageTagAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.image_tag_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetImageTagAssignments resets all changes to the "image_tag_assignments" edge.
func (m *ImageTagMutation) ResetImageTagAssignments() {
	m.image_tag_assignments = nil
	m.clearedimage_tag_assignments = false
	m.removedimage_tag_assignments = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ImageTagMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ImageTagMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ImageTagMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ImageTagMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ImageTagMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ImageTagMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ImageTagMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ImageTagMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ImageTagMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ImageTagMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ImageTagMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ImageTagMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the ImageTagMutation builder.
func (m *ImageTagMutation) Where(ps ...predicate.ImageTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImageTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImageTag).
func (m *ImageTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageTagMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, imagetag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, imagetag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, imagetag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, imagetag.FieldDescription)
	}
	if m.is_album != nil {
		fields = append(fields, imagetag.FieldIsAlbum)
	}
	if m._type != nil {
		fields = append(fields, imagetag.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case imagetag.FieldCreatedAt:
		return m.CreatedAt()
	case imagetag.FieldUpdatedAt:
		return m.UpdatedAt()
	case imagetag.FieldName:
		return m.Name()
	case imagetag.FieldDescription:
		return m.Description()
	case imagetag.FieldIsAlbum:
		return m.IsAlbum()
	case imagetag.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case imagetag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case imagetag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case imagetag.FieldName:
		return m.OldName(ctx)
	case imagetag.FieldDescription:
		return m.OldDescription(ctx)
	case imagetag.FieldIsAlbum:
		return m.OldIsAlbum(ctx)
	case imagetag.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ImageTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case imagetag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case imagetag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case imagetag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case imagetag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case imagetag.FieldIsAlbum:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAlbum(v)
		return nil
	case imagetag.FieldType:
		v, ok := value.(imagetag.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ImageTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImageTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ImageTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageTagMutation) ResetField(name string) error {
	switch name {
	case imagetag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case imagetag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case imagetag.FieldName:
		m.ResetName()
		return nil
	case imagetag.FieldDescription:
		m.ResetDescription()
		return nil
	case imagetag.FieldIsAlbum:
		m.ResetIsAlbum()
		return nil
	case imagetag.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ImageTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.project != nil {
		edges = append(edges, imagetag.EdgeProject)
	}
	if m.image_tag_assignments != nil {
		edges = append(edges, imagetag.EdgeImageTagAssignments)
	}
	if m.created_by != nil {
		edges = append(edges, imagetag.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, imagetag.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case imagetag.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case imagetag.EdgeImageTagAssignments:
		ids := make([]ent.Value, 0, len(m.image_tag_assignments))
		for id := range m.image_tag_assignments {
			ids = append(ids, id)
		}
		return ids
	case imagetag.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case imagetag.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedimage_tag_assignments != nil {
		edges = append(edges, imagetag.EdgeImageTagAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case imagetag.EdgeImageTagAssignments:
		ids := make([]ent.Value, 0, len(m.removedimage_tag_assignments))
		for id := range m.removedimage_tag_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproject {
		edges = append(edges, imagetag.EdgeProject)
	}
	if m.clearedimage_tag_assignments {
		edges = append(edges, imagetag.EdgeImageTagAssignments)
	}
	if m.clearedcreated_by {
		edges = append(edges, imagetag.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, imagetag.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageTagMutation) EdgeCleared(name string) bool {
	switch name {
	case imagetag.EdgeProject:
		return m.clearedproject
	case imagetag.EdgeImageTagAssignments:
		return m.clearedimage_tag_assignments
	case imagetag.EdgeCreatedBy:
		return m.clearedcreated_by
	case imagetag.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageTagMutation) ClearEdge(name string) error {
	switch name {
	case imagetag.EdgeProject:
		m.ClearProject()
		return nil
	case imagetag.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case imagetag.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ImageTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageTagMutation) ResetEdge(name string) error {
	switch name {
	case imagetag.EdgeProject:
		m.ResetProject()
		return nil
	case imagetag.EdgeImageTagAssignments:
		m.ResetImageTagAssignments()
		return nil
	case imagetag.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case imagetag.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ImageTag edge %s", name)
}

// ImageTagAssignmentMutation represents an operation that mutates the ImageTagAssignment nodes in the graph.
type ImageTagAssignmentMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_type             *imagetagassignment.Type
	clearedFields     map[string]struct{}
	image             *uuid.UUID
	clearedimage      bool
	image_tag         *uuid.UUID
	clearedimage_tag  bool
	created_by        *uuid.UUID
	clearedcreated_by bool
	updated_by        *uuid.UUID
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*ImageTagAssignment, error)
	predicates        []predicate.ImageTagAssignment
}

var _ ent.Mutation = (*ImageTagAssignmentMutation)(nil)

// imagetagassignmentOption allows management of the mutation configuration using functional options.
type imagetagassignmentOption func(*ImageTagAssignmentMutation)

// newImageTagAssignmentMutation creates new mutation for the ImageTagAssignment entity.
func newImageTagAssignmentMutation(c config, op Op, opts ...imagetagassignmentOption) *ImageTagAssignmentMutation {
	m := &ImageTagAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeImageTagAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageTagAssignmentID sets the ID field of the mutation.
func withImageTagAssignmentID(id uuid.UUID) imagetagassignmentOption {
	return func(m *ImageTagAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *ImageTagAssignment
		)
		m.oldValue = func(ctx context.Context) (*ImageTagAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImageTagAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImageTagAssignment sets the old ImageTagAssignment of the mutation.
func withImageTagAssignment(node *ImageTagAssignment) imagetagassignmentOption {
	return func(m *ImageTagAssignmentMutation) {
		m.oldValue = func(context.Context) (*ImageTagAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageTagAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageTagAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ImageTagAssignment entities.
func (m *ImageTagAssignmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageTagAssignmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageTagAssignmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImageTagAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageTagAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageTagAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImageTagAssignment entity.
// If the ImageTagAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageTagAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageTagAssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageTagAssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ImageTagAssignment entity.
// If the ImageTagAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagAssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageTagAssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *ImageTagAssignmentMutation) SetType(i imagetagassignment.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ImageTagAssignmentMutation) GetType() (r imagetagassignment.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ImageTagAssignment entity.
// If the ImageTagAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagAssignmentMutation) OldType(ctx context.Context) (v imagetagassignment.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ImageTagAssignmentMutation) ResetType() {
	m._type = nil
}

// SetImageID sets the "image" edge to the Image entity by id.
func (m *ImageTagAssignmentMutation) SetImageID(id uuid.UUID) {
	m.image = &id
}

// ClearImage clears the "image" edge to the Image entity.
func (m *ImageTagAssignmentMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *ImageTagAssignmentMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageID returns the "image" edge ID in the mutation.
func (m *ImageTagAssignmentMutation) ImageID() (id uuid.UUID, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *ImageTagAssignmentMutation) ImageIDs() (ids []uuid.UUID) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *ImageTagAssignmentMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// SetImageTagID sets the "image_tag" edge to the ImageTag entity by id.
func (m *ImageTagAssignmentMutation) SetImageTagID(id uuid.UUID) {
	m.image_tag = &id
}

// ClearImageTag clears the "image_tag" edge to the ImageTag entity.
func (m *ImageTagAssignmentMutation) ClearImageTag() {
	m.clearedimage_tag = true
}

// ImageTagCleared reports if the "image_tag" edge to the ImageTag entity was cleared.
func (m *ImageTagAssignmentMutation) ImageTagCleared() bool {
	return m.clearedimage_tag
}

// ImageTagID returns the "image_tag" edge ID in the mutation.
func (m *ImageTagAssignmentMutation) ImageTagID() (id uuid.UUID, exists bool) {
	if m.image_tag != nil {
		return *m.image_tag, true
	}
	return
}

// ImageTagIDs returns the "image_tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageTagID instead. It exists only for internal usage by the builders.
func (m *ImageTagAssignmentMutation) ImageTagIDs() (ids []uuid.UUID) {
	if id := m.image_tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImageTag resets all changes to the "image_tag" edge.
func (m *ImageTagAssignmentMutation) ResetImageTag() {
	m.image_tag = nil
	m.clearedimage_tag = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ImageTagAssignmentMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ImageTagAssignmentMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ImageTagAssignmentMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ImageTagAssignmentMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ImageTagAssignmentMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ImageTagAssignmentMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ImageTagAssignmentMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ImageTagAssignmentMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ImageTagAssignmentMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ImageTagAssignmentMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ImageTagAssignmentMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ImageTagAssignmentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the ImageTagAssignmentMutation builder.
func (m *ImageTagAssignmentMutation) Where(ps ...predicate.ImageTagAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageTagAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageTagAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImageTagAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageTagAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageTagAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImageTagAssignment).
func (m *ImageTagAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageTagAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, imagetagassignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, imagetagassignment.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, imagetagassignment.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageTagAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case imagetagassignment.FieldCreatedAt:
		return m.CreatedAt()
	case imagetagassignment.FieldUpdatedAt:
		return m.UpdatedAt()
	case imagetagassignment.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageTagAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case imagetagassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case imagetagassignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case imagetagassignment.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ImageTagAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageTagAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case imagetagassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case imagetagassignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case imagetagassignment.FieldType:
		v, ok := value.(imagetagassignment.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ImageTagAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageTagAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageTagAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageTagAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImageTagAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageTagAssignmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageTagAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageTagAssignmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ImageTagAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageTagAssignmentMutation) ResetField(name string) error {
	switch name {
	case imagetagassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case imagetagassignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case imagetagassignment.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ImageTagAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageTagAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.image != nil {
		edges = append(edges, imagetagassignment.EdgeImage)
	}
	if m.image_tag != nil {
		edges = append(edges, imagetagassignment.EdgeImageTag)
	}
	if m.created_by != nil {
		edges = append(edges, imagetagassignment.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, imagetagassignment.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageTagAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case imagetagassignment.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	case imagetagassignment.EdgeImageTag:
		if id := m.image_tag; id != nil {
			return []ent.Value{*id}
		}
	case imagetagassignment.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case imagetagassignment.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageTagAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageTagAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageTagAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedimage {
		edges = append(edges, imagetagassignment.EdgeImage)
	}
	if m.clearedimage_tag {
		edges = append(edges, imagetagassignment.EdgeImageTag)
	}
	if m.clearedcreated_by {
		edges = append(edges, imagetagassignment.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, imagetagassignment.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageTagAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case imagetagassignment.EdgeImage:
		return m.clearedimage
	case imagetagassignment.EdgeImageTag:
		return m.clearedimage_tag
	case imagetagassignment.EdgeCreatedBy:
		return m.clearedcreated_by
	case imagetagassignment.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageTagAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case imagetagassignment.EdgeImage:
		m.ClearImage()
		return nil
	case imagetagassignment.EdgeImageTag:
		m.ClearImageTag()
		return nil
	case imagetagassignment.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case imagetagassignment.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ImageTagAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageTagAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case imagetagassignment.EdgeImage:
		m.ResetImage()
		return nil
	case imagetagassignment.EdgeImageTag:
		m.ResetImageTag()
		return nil
	case imagetagassignment.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case imagetagassignment.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ImageTagAssignment edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	description         *string
	copyright           *string
	copyright_reference *string
	location_name       *string
	location_code       *string
	location_city       *string
	clearedFields       map[string]struct{}
	assignments         map[uuid.UUID]struct{}
	removedassignments  map[uuid.UUID]struct{}
	clearedassignments  bool
	images              map[uuid.UUID]struct{}
	removedimages       map[uuid.UUID]struct{}
	clearedimages       bool
	batches             map[uuid.UUID]struct{}
	removedbatches      map[uuid.UUID]struct{}
	clearedbatches      bool
	tags                map[uuid.UUID]struct{}
	removedtags         map[uuid.UUID]struct{}
	clearedtags         bool
	created_by          *uuid.UUID
	clearedcreated_by   bool
	updated_by          *uuid.UUID
	clearedupdated_by   bool
	done                bool
	oldValue            func(context.Context) (*Project, error)
	predicates          []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id uuid.UUID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// SetCopyright sets the "copyright" field.
func (m *ProjectMutation) SetCopyright(s string) {
	m.copyright = &s
}

// Copyright returns the value of the "copyright" field in the mutation.
func (m *ProjectMutation) Copyright() (r string, exists bool) {
	v := m.copyright
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyright returns the old "copyright" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCopyright(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyright is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyright requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyright: %w", err)
	}
	return oldValue.Copyright, nil
}

// ResetCopyright resets all changes to the "copyright" field.
func (m *ProjectMutation) ResetCopyright() {
	m.copyright = nil
}

// SetCopyrightReference sets the "copyright_reference" field.
func (m *ProjectMutation) SetCopyrightReference(s string) {
	m.copyright_reference = &s
}

// CopyrightReference returns the value of the "copyright_reference" field in the mutation.
func (m *ProjectMutation) CopyrightReference() (r string, exists bool) {
	v := m.copyright_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyrightReference returns the old "copyright_reference" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCopyrightReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyrightReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyrightReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyrightReference: %w", err)
	}
	return oldValue.CopyrightReference, nil
}

// ResetCopyrightReference resets all changes to the "copyright_reference" field.
func (m *ProjectMutation) ResetCopyrightReference() {
	m.copyright_reference = nil
}

// SetLocationName sets the "location_name" field.
func (m *ProjectMutation) SetLocationName(s string) {
	m.location_name = &s
}

// LocationName returns the value of the "location_name" field in the mutation.
func (m *ProjectMutation) LocationName() (r string, exists bool) {
	v := m.location_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationName returns the old "location_name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldLocationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationName: %w", err)
	}
	return oldValue.LocationName, nil
}

// ResetLocationName resets all changes to the "location_name" field.
func (m *ProjectMutation) ResetLocationName() {
	m.location_name = nil
}

// SetLocationCode sets the "location_code" field.
func (m *ProjectMutation) SetLocationCode(s string) {
	m.location_code = &s
}

// LocationCode returns the value of the "location_code" field in the mutation.
func (m *ProjectMutation) LocationCode() (r string, exists bool) {
	v := m.location_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationCode returns the old "location_code" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldLocationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationCode: %w", err)
	}
	return oldValue.LocationCode, nil
}

// ResetLocationCode resets all changes to the "location_code" field.
func (m *ProjectMutation) ResetLocationCode() {
	m.location_code = nil
}

// SetLocationCity sets the "location_city" field.
func (m *ProjectMutation) SetLocationCity(s string) {
	m.location_city = &s
}

// LocationCity returns the value of the "location_city" field in the mutation.
func (m *ProjectMutation) LocationCity() (r string, exists bool) {
	v := m.location_city
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationCity returns the old "location_city" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldLocationCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationCity: %w", err)
	}
	return oldValue.LocationCity, nil
}

// ResetLocationCity resets all changes to the "location_city" field.
func (m *ProjectMutation) ResetLocationCity() {
	m.location_city = nil
}

// AddAssignmentIDs adds the "assignments" edge to the ProjectAssignment entity by ids.
func (m *ProjectMutation) AddAssignmentIDs(ids ...uuid.UUID) {
	if m.assignments == nil {
		m.assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the ProjectAssignment entity.
func (m *ProjectMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the ProjectAssignment entity was cleared.
func (m *ProjectMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the ProjectAssignment entity by IDs.
func (m *ProjectMutation) RemoveAssignmentIDs(ids ...uuid.UUID) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the ProjectAssignment entity.
func (m *ProjectMutation) RemovedAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *ProjectMutation) AssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *ProjectMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *ProjectMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *ProjectMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *ProjectMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *ProjectMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *ProjectMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ProjectMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ProjectMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddBatchIDs adds the "batches" edge to the Batch entity by ids.
func (m *ProjectMutation) AddBatchIDs(ids ...uuid.UUID) {
	if m.batches == nil {
		m.batches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.batches[ids[i]] = struct{}{}
	}
}

// ClearBatches clears the "batches" edge to the Batch entity.
func (m *ProjectMutation) ClearBatches() {
	m.clearedbatches = true
}

// BatchesCleared reports if the "batches" edge to the Batch entity was cleared.
func (m *ProjectMutation) BatchesCleared() bool {
	return m.clearedbatches
}

// RemoveBatchIDs removes the "batches" edge to the Batch entity by IDs.
func (m *ProjectMutation) RemoveBatchIDs(ids ...uuid.UUID) {
	if m.removedbatches == nil {
		m.removedbatches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.batches, ids[i])
		m.removedbatches[ids[i]] = struct{}{}
	}
}

// RemovedBatches returns the removed IDs of the "batches" edge to the Batch entity.
func (m *ProjectMutation) RemovedBatchesIDs() (ids []uuid.UUID) {
	for id := range m.removedbatches {
		ids = append(ids, id)
	}
	return
}

// BatchesIDs returns the "batches" edge IDs in the mutation.
func (m *ProjectMutation) BatchesIDs() (ids []uuid.UUID) {
	for id := range m.batches {
		ids = append(ids, id)
	}
	return
}

// ResetBatches resets all changes to the "batches" edge.
func (m *ProjectMutation) ResetBatches() {
	m.batches = nil
	m.clearedbatches = false
	m.removedbatches = nil
}

// AddTagIDs adds the "tags" edge to the ImageTag entity by ids.
func (m *ProjectMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the ImageTag entity.
func (m *ProjectMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the ImageTag entity was cleared.
func (m *ProjectMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the ImageTag entity by IDs.
func (m *ProjectMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the ImageTag entity.
func (m *ProjectMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ProjectMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProjectMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ProjectMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ProjectMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ProjectMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ProjectMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ProjectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ProjectMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ProjectMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ProjectMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ProjectMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ProjectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.copyright != nil {
		fields = append(fields, project.FieldCopyright)
	}
	if m.copyright_reference != nil {
		fields = append(fields, project.FieldCopyrightReference)
	}
	if m.location_name != nil {
		fields = append(fields, project.FieldLocationName)
	}
	if m.location_code != nil {
		fields = append(fields, project.FieldLocationCode)
	}
	if m.location_city != nil {
		fields = append(fields, project.FieldLocationCity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldCopyright:
		return m.Copyright()
	case project.FieldCopyrightReference:
		return m.CopyrightReference()
	case project.FieldLocationName:
		return m.LocationName()
	case project.FieldLocationCode:
		return m.LocationCode()
	case project.FieldLocationCity:
		return m.LocationCity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldCopyright:
		return m.OldCopyright(ctx)
	case project.FieldCopyrightReference:
		return m.OldCopyrightReference(ctx)
	case project.FieldLocationName:
		return m.OldLocationName(ctx)
	case project.FieldLocationCode:
		return m.OldLocationCode(ctx)
	case project.FieldLocationCity:
		return m.OldLocationCity(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldCopyright:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyright(v)
		return nil
	case project.FieldCopyrightReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyrightReference(v)
		return nil
	case project.FieldLocationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationName(v)
		return nil
	case project.FieldLocationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationCode(v)
		return nil
	case project.FieldLocationCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationCity(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldCopyright:
		m.ResetCopyright()
		return nil
	case project.FieldCopyrightReference:
		m.ResetCopyrightReference()
		return nil
	case project.FieldLocationName:
		m.ResetLocationName()
		return nil
	case project.FieldLocationCode:
		m.ResetLocationCode()
		return nil
	case project.FieldLocationCity:
		m.ResetLocationCity()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.assignments != nil {
		edges = append(edges, project.EdgeAssignments)
	}
	if m.images != nil {
		edges = append(edges, project.EdgeImages)
	}
	if m.batches != nil {
		edges = append(edges, project.EdgeBatches)
	}
	if m.tags != nil {
		edges = append(edges, project.EdgeTags)
	}
	if m.created_by != nil {
		edges = append(edges, project.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, project.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeBatches:
		ids := make([]ent.Value, 0, len(m.batches))
		for id := range m.batches {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedassignments != nil {
		edges = append(edges, project.EdgeAssignments)
	}
	if m.removedimages != nil {
		edges = append(edges, project.EdgeImages)
	}
	if m.removedbatches != nil {
		edges = append(edges, project.EdgeBatches)
	}
	if m.removedtags != nil {
		edges = append(edges, project.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeBatches:
		ids := make([]ent.Value, 0, len(m.removedbatches))
		for id := range m.removedbatches {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedassignments {
		edges = append(edges, project.EdgeAssignments)
	}
	if m.clearedimages {
		edges = append(edges, project.EdgeImages)
	}
	if m.clearedbatches {
		edges = append(edges, project.EdgeBatches)
	}
	if m.clearedtags {
		edges = append(edges, project.EdgeTags)
	}
	if m.clearedcreated_by {
		edges = append(edges, project.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, project.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeAssignments:
		return m.clearedassignments
	case project.EdgeImages:
		return m.clearedimages
	case project.EdgeBatches:
		return m.clearedbatches
	case project.EdgeTags:
		return m.clearedtags
	case project.EdgeCreatedBy:
		return m.clearedcreated_by
	case project.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case project.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeAssignments:
		m.ResetAssignments()
		return nil
	case project.EdgeImages:
		m.ResetImages()
		return nil
	case project.EdgeBatches:
		m.ResetBatches()
		return nil
	case project.EdgeTags:
		m.ResetTags()
		return nil
	case project.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case project.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectAssignmentMutation represents an operation that mutates the ProjectAssignment nodes in the graph.
type ProjectAssignmentMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	project           *uuid.UUID
	clearedproject    bool
	role              *uuid.UUID
	clearedrole       bool
	created_by        *uuid.UUID
	clearedcreated_by bool
	updated_by        *uuid.UUID
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*ProjectAssignment, error)
	predicates        []predicate.ProjectAssignment
}

var _ ent.Mutation = (*ProjectAssignmentMutation)(nil)

// projectassignmentOption allows management of the mutation configuration using functional options.
type projectassignmentOption func(*ProjectAssignmentMutation)

// newProjectAssignmentMutation creates new mutation for the ProjectAssignment entity.
func newProjectAssignmentMutation(c config, op Op, opts ...projectassignmentOption) *ProjectAssignmentMutation {
	m := &ProjectAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectAssignmentID sets the ID field of the mutation.
func withProjectAssignmentID(id uuid.UUID) projectassignmentOption {
	return func(m *ProjectAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectAssignment
		)
		m.oldValue = func(ctx context.Context) (*ProjectAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectAssignment sets the old ProjectAssignment of the mutation.
func withProjectAssignment(node *ProjectAssignment) projectassignmentOption {
	return func(m *ProjectAssignmentMutation) {
		m.oldValue = func(context.Context) (*ProjectAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectAssignment entities.
func (m *ProjectAssignmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectAssignmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectAssignmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectAssignment entity.
// If the ProjectAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectAssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectAssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectAssignment entity.
// If the ProjectAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectAssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectAssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProjectAssignmentMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProjectAssignmentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProjectAssignmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProjectAssignmentMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProjectAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectAssignmentMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectAssignmentMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectAssignmentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectAssignmentMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectAssignmentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *ProjectAssignmentMutation) SetRoleID(id uuid.UUID) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *ProjectAssignmentMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *ProjectAssignmentMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *ProjectAssignmentMutation) RoleID() (id uuid.UUID, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *ProjectAssignmentMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ProjectAssignmentMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ProjectAssignmentMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ProjectAssignmentMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ProjectAssignmentMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ProjectAssignmentMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ProjectAssignmentMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ProjectAssignmentMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ProjectAssignmentMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ProjectAssignmentMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ProjectAssignmentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the ProjectAssignmentMutation builder.
func (m *ProjectAssignmentMutation) Where(ps ...predicate.ProjectAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectAssignment).
func (m *ProjectAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, projectassignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projectassignment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectassignment.FieldCreatedAt:
		return m.CreatedAt()
	case projectassignment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectassignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectassignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectAssignmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectAssignmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectAssignmentMutation) ResetField(name string) error {
	switch name {
	case projectassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectassignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, projectassignment.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, projectassignment.EdgeProject)
	}
	if m.role != nil {
		edges = append(edges, projectassignment.EdgeRole)
	}
	if m.created_by != nil {
		edges = append(edges, projectassignment.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, projectassignment.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case projectassignment.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectassignment.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case projectassignment.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case projectassignment.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, projectassignment.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, projectassignment.EdgeProject)
	}
	if m.clearedrole {
		edges = append(edges, projectassignment.EdgeRole)
	}
	if m.clearedcreated_by {
		edges = append(edges, projectassignment.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, projectassignment.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case projectassignment.EdgeUser:
		return m.cleareduser
	case projectassignment.EdgeProject:
		return m.clearedproject
	case projectassignment.EdgeRole:
		return m.clearedrole
	case projectassignment.EdgeCreatedBy:
		return m.clearedcreated_by
	case projectassignment.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case projectassignment.EdgeUser:
		m.ClearUser()
		return nil
	case projectassignment.EdgeProject:
		m.ClearProject()
		return nil
	case projectassignment.EdgeRole:
		m.ClearRole()
		return nil
	case projectassignment.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case projectassignment.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ProjectAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case projectassignment.EdgeUser:
		m.ResetUser()
		return nil
	case projectassignment.EdgeProject:
		m.ResetProject()
		return nil
	case projectassignment.EdgeRole:
		m.ResetRole()
		return nil
	case projectassignment.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case projectassignment.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ProjectAssignment edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	key                       *string
	description               *string
	clearedFields             map[string]struct{}
	users                     map[uuid.UUID]struct{}
	removedusers              map[uuid.UUID]struct{}
	clearedusers              bool
	projectAssignments        map[uuid.UUID]struct{}
	removedprojectAssignments map[uuid.UUID]struct{}
	clearedprojectAssignments bool
	done                      bool
	oldValue                  func(context.Context) (*Role, error)
	predicates                []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "key" field.
func (m *RoleMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *RoleMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *RoleMutation) ResetKey() {
	m.key = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddProjectAssignmentIDs adds the "projectAssignments" edge to the ProjectAssignment entity by ids.
func (m *RoleMutation) AddProjectAssignmentIDs(ids ...uuid.UUID) {
	if m.projectAssignments == nil {
		m.projectAssignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.projectAssignments[ids[i]] = struct{}{}
	}
}

// ClearProjectAssignments clears the "projectAssignments" edge to the ProjectAssignment entity.
func (m *RoleMutation) ClearProjectAssignments() {
	m.clearedprojectAssignments = true
}

// ProjectAssignmentsCleared reports if the "projectAssignments" edge to the ProjectAssignment entity was cleared.
func (m *RoleMutation) ProjectAssignmentsCleared() bool {
	return m.clearedprojectAssignments
}

// RemoveProjectAssignmentIDs removes the "projectAssignments" edge to the ProjectAssignment entity by IDs.
func (m *RoleMutation) RemoveProjectAssignmentIDs(ids ...uuid.UUID) {
	if m.removedprojectAssignments == nil {
		m.removedprojectAssignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.projectAssignments, ids[i])
		m.removedprojectAssignments[ids[i]] = struct{}{}
	}
}

// RemovedProjectAssignments returns the removed IDs of the "projectAssignments" edge to the ProjectAssignment entity.
func (m *RoleMutation) RemovedProjectAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedprojectAssignments {
		ids = append(ids, id)
	}
	return
}

// ProjectAssignmentsIDs returns the "projectAssignments" edge IDs in the mutation.
func (m *RoleMutation) ProjectAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.projectAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetProjectAssignments resets all changes to the "projectAssignments" edge.
func (m *RoleMutation) ResetProjectAssignments() {
	m.projectAssignments = nil
	m.clearedprojectAssignments = false
	m.removedprojectAssignments = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, role.FieldKey)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldKey:
		return m.Key()
	case role.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldKey:
		return m.OldKey(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldKey:
		m.ResetKey()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.projectAssignments != nil {
		edges = append(edges, role.EdgeProjectAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeProjectAssignments:
		ids := make([]ent.Value, 0, len(m.projectAssignments))
		for id := range m.projectAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removedprojectAssignments != nil {
		edges = append(edges, role.EdgeProjectAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeProjectAssignments:
		ids := make([]ent.Value, 0, len(m.removedprojectAssignments))
		for id := range m.removedprojectAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedprojectAssignments {
		edges = append(edges, role.EdgeProjectAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgeProjectAssignments:
		return m.clearedprojectAssignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgeProjectAssignments:
		m.ResetProjectAssignments()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// TimeOffsetMutation represents an operation that mutates the TimeOffset nodes in the graph.
type TimeOffsetMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	server_time       *time.Time
	camera_time       *time.Time
	offset_seconds    *int
	addoffset_seconds *int
	clearedFields     map[string]struct{}
	camera            *uuid.UUID
	clearedcamera     bool
	created_by        *uuid.UUID
	clearedcreated_by bool
	updated_by        *uuid.UUID
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*TimeOffset, error)
	predicates        []predicate.TimeOffset
}

var _ ent.Mutation = (*TimeOffsetMutation)(nil)

// timeoffsetOption allows management of the mutation configuration using functional options.
type timeoffsetOption func(*TimeOffsetMutation)

// newTimeOffsetMutation creates new mutation for the TimeOffset entity.
func newTimeOffsetMutation(c config, op Op, opts ...timeoffsetOption) *TimeOffsetMutation {
	m := &TimeOffsetMutation{
		config:        c,
		op:            op,
		typ:           TypeTimeOffset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeOffsetID sets the ID field of the mutation.
func withTimeOffsetID(id uuid.UUID) timeoffsetOption {
	return func(m *TimeOffsetMutation) {
		var (
			err   error
			once  sync.Once
			value *TimeOffset
		)
		m.oldValue = func(ctx context.Context) (*TimeOffset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimeOffset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimeOffset sets the old TimeOffset of the mutation.
func withTimeOffset(node *TimeOffset) timeoffsetOption {
	return func(m *TimeOffsetMutation) {
		m.oldValue = func(context.Context) (*TimeOffset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeOffsetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeOffsetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TimeOffset entities.
func (m *TimeOffsetMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeOffsetMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeOffsetMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimeOffset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TimeOffsetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimeOffsetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimeOffsetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TimeOffsetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TimeOffsetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TimeOffsetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetServerTime sets the "server_time" field.
func (m *TimeOffsetMutation) SetServerTime(t time.Time) {
	m.server_time = &t
}

// ServerTime returns the value of the "server_time" field in the mutation.
func (m *TimeOffsetMutation) ServerTime() (r time.Time, exists bool) {
	v := m.server_time
	if v == nil {
		return
	}
	return *v, true
}

// OldServerTime returns the old "server_time" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldServerTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerTime: %w", err)
	}
	return oldValue.ServerTime, nil
}

// ResetServerTime resets all changes to the "server_time" field.
func (m *TimeOffsetMutation) ResetServerTime() {
	m.server_time = nil
}

// SetCameraTime sets the "camera_time" field.
func (m *TimeOffsetMutation) SetCameraTime(t time.Time) {
	m.camera_time = &t
}

// CameraTime returns the value of the "camera_time" field in the mutation.
func (m *TimeOffsetMutation) CameraTime() (r time.Time, exists bool) {
	v := m.camera_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCameraTime returns the old "camera_time" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldCameraTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCameraTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCameraTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCameraTime: %w", err)
	}
	return oldValue.CameraTime, nil
}

// ResetCameraTime resets all changes to the "camera_time" field.
func (m *TimeOffsetMutation) ResetCameraTime() {
	m.camera_time = nil
}

// SetOffsetSeconds sets the "offset_seconds" field.
func (m *TimeOffsetMutation) SetOffsetSeconds(i int) {
	m.offset_seconds = &i
	m.addoffset_seconds = nil
}

// OffsetSeconds returns the value of the "offset_seconds" field in the mutation.
func (m *TimeOffsetMutation) OffsetSeconds() (r int, exists bool) {
	v := m.offset_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldOffsetSeconds returns the old "offset_seconds" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldOffsetSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOffsetSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOffsetSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOffsetSeconds: %w", err)
	}
	return oldValue.OffsetSeconds, nil
}

// AddOffsetSeconds adds i to the "offset_seconds" field.
func (m *TimeOffsetMutation) AddOffsetSeconds(i int) {
	if m.addoffset_seconds != nil {
		*m.addoffset_seconds += i
	} else {
		m.addoffset_seconds = &i
	}
}

// AddedOffsetSeconds returns the value that was added to the "offset_seconds" field in this mutation.
func (m *TimeOffsetMutation) AddedOffsetSeconds() (r int, exists bool) {
	v := m.addoffset_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetOffsetSeconds resets all changes to the "offset_seconds" field.
func (m *TimeOffsetMutation) ResetOffsetSeconds() {
	m.offset_seconds = nil
	m.addoffset_seconds = nil
}

// SetCameraID sets the "camera" edge to the Camera entity by id.
func (m *TimeOffsetMutation) SetCameraID(id uuid.UUID) {
	m.camera = &id
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *TimeOffsetMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *TimeOffsetMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraID returns the "camera" edge ID in the mutation.
func (m *TimeOffsetMutation) CameraID() (id uuid.UUID, exists bool) {
	if m.camera != nil {
		return *m.camera, true
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *TimeOffsetMutation) CameraIDs() (ids []uuid.UUID) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *TimeOffsetMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *TimeOffsetMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *TimeOffsetMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *TimeOffsetMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *TimeOffsetMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *TimeOffsetMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *TimeOffsetMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *TimeOffsetMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *TimeOffsetMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *TimeOffsetMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *TimeOffsetMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *TimeOffsetMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *TimeOffsetMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the TimeOffsetMutation builder.
func (m *TimeOffsetMutation) Where(ps ...predicate.TimeOffset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimeOffsetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimeOffsetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimeOffset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimeOffsetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimeOffsetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimeOffset).
func (m *TimeOffsetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeOffsetMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, timeoffset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, timeoffset.FieldUpdatedAt)
	}
	if m.server_time != nil {
		fields = append(fields, timeoffset.FieldServerTime)
	}
	if m.camera_time != nil {
		fields = append(fields, timeoffset.FieldCameraTime)
	}
	if m.offset_seconds != nil {
		fields = append(fields, timeoffset.FieldOffsetSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeOffsetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timeoffset.FieldCreatedAt:
		return m.CreatedAt()
	case timeoffset.FieldUpdatedAt:
		return m.UpdatedAt()
	case timeoffset.FieldServerTime:
		return m.ServerTime()
	case timeoffset.FieldCameraTime:
		return m.CameraTime()
	case timeoffset.FieldOffsetSeconds:
		return m.OffsetSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeOffsetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timeoffset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case timeoffset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case timeoffset.FieldServerTime:
		return m.OldServerTime(ctx)
	case timeoffset.FieldCameraTime:
		return m.OldCameraTime(ctx)
	case timeoffset.FieldOffsetSeconds:
		return m.OldOffsetSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown TimeOffset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffsetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timeoffset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case timeoffset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case timeoffset.FieldServerTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerTime(v)
		return nil
	case timeoffset.FieldCameraTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCameraTime(v)
		return nil
	case timeoffset.FieldOffsetSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOffsetSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeOffsetMutation) AddedFields() []string {
	var fields []string
	if m.addoffset_seconds != nil {
		fields = append(fields, timeoffset.FieldOffsetSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeOffsetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timeoffset.FieldOffsetSeconds:
		return m.AddedOffsetSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffsetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timeoffset.FieldOffsetSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOffsetSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeOffsetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeOffsetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeOffsetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TimeOffset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeOffsetMutation) ResetField(name string) error {
	switch name {
	case timeoffset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case timeoffset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case timeoffset.FieldServerTime:
		m.ResetServerTime()
		return nil
	case timeoffset.FieldCameraTime:
		m.ResetCameraTime()
		return nil
	case timeoffset.FieldOffsetSeconds:
		m.ResetOffsetSeconds()
		return nil
	}
	return fmt.Errorf("unknown TimeOffset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeOffsetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.camera != nil {
		edges = append(edges, timeoffset.EdgeCamera)
	}
	if m.created_by != nil {
		edges = append(edges, timeoffset.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, timeoffset.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeOffsetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timeoffset.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	case timeoffset.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case timeoffset.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeOffsetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeOffsetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeOffsetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcamera {
		edges = append(edges, timeoffset.EdgeCamera)
	}
	if m.clearedcreated_by {
		edges = append(edges, timeoffset.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, timeoffset.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeOffsetMutation) EdgeCleared(name string) bool {
	switch name {
	case timeoffset.EdgeCamera:
		return m.clearedcamera
	case timeoffset.EdgeCreatedBy:
		return m.clearedcreated_by
	case timeoffset.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeOffsetMutation) ClearEdge(name string) error {
	switch name {
	case timeoffset.EdgeCamera:
		m.ClearCamera()
		return nil
	case timeoffset.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case timeoffset.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown TimeOffset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeOffsetMutation) ResetEdge(name string) error {
	switch name {
	case timeoffset.EdgeCamera:
		m.ResetCamera()
		return nil
	case timeoffset.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case timeoffset.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown TimeOffset edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	first_name                *string
	last_name                 *string
	email                     *string
	copyright_tag             *string
	email_validated           *bool
	validation_key            *uuid.UUID
	validation_sent_at        *time.Time
	password                  *[]byte
	password_reset_key        *uuid.UUID
	password_reset_at         *time.Time
	active                    *bool
	clearedFields             map[string]struct{}
	role                      *uuid.UUID
	clearedrole               bool
	projectAssignments        map[uuid.UUID]struct{}
	removedprojectAssignments map[uuid.UUID]struct{}
	clearedprojectAssignments bool
	images                    map[uuid.UUID]struct{}
	removedimages             map[uuid.UUID]struct{}
	clearedimages             bool
	cameras                   map[uuid.UUID]struct{}
	removedcameras            map[uuid.UUID]struct{}
	clearedcameras            bool
	apiKey                    map[uuid.UUID]struct{}
	removedapiKey             map[uuid.UUID]struct{}
	clearedapiKey             bool
	created_users             map[uuid.UUID]struct{}
	removedcreated_users      map[uuid.UUID]struct{}
	clearedcreated_users      bool
	created_by                *uuid.UUID
	clearedcreated_by         bool
	modified_users            map[uuid.UUID]struct{}
	removedmodified_users     map[uuid.UUID]struct{}
	clearedmodified_users     bool
	updated_by                *uuid.UUID
	clearedupdated_by         bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetCopyrightTag sets the "copyright_tag" field.
func (m *UserMutation) SetCopyrightTag(s string) {
	m.copyright_tag = &s
}

// CopyrightTag returns the value of the "copyright_tag" field in the mutation.
func (m *UserMutation) CopyrightTag() (r string, exists bool) {
	v := m.copyright_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyrightTag returns the old "copyright_tag" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCopyrightTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyrightTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyrightTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyrightTag: %w", err)
	}
	return oldValue.CopyrightTag, nil
}

// ResetCopyrightTag resets all changes to the "copyright_tag" field.
func (m *UserMutation) ResetCopyrightTag() {
	m.copyright_tag = nil
}

// SetEmailValidated sets the "email_validated" field.
func (m *UserMutation) SetEmailValidated(b bool) {
	m.email_validated = &b
}

// EmailValidated returns the value of the "email_validated" field in the mutation.
func (m *UserMutation) EmailValidated() (r bool, exists bool) {
	v := m.email_validated
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailValidated returns the old "email_validated" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailValidated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailValidated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailValidated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailValidated: %w", err)
	}
	return oldValue.EmailValidated, nil
}

// ResetEmailValidated resets all changes to the "email_validated" field.
func (m *UserMutation) ResetEmailValidated() {
	m.email_validated = nil
}

// SetValidationKey sets the "validation_key" field.
func (m *UserMutation) SetValidationKey(u uuid.UUID) {
	m.validation_key = &u
}

// ValidationKey returns the value of the "validation_key" field in the mutation.
func (m *UserMutation) ValidationKey() (r uuid.UUID, exists bool) {
	v := m.validation_key
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationKey returns the old "validation_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldValidationKey(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationKey: %w", err)
	}
	return oldValue.ValidationKey, nil
}

// ResetValidationKey resets all changes to the "validation_key" field.
func (m *UserMutation) ResetValidationKey() {
	m.validation_key = nil
}

// SetValidationSentAt sets the "validation_sent_at" field.
func (m *UserMutation) SetValidationSentAt(t time.Time) {
	m.validation_sent_at = &t
}

// ValidationSentAt returns the value of the "validation_sent_at" field in the mutation.
func (m *UserMutation) ValidationSentAt() (r time.Time, exists bool) {
	v := m.validation_sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationSentAt returns the old "validation_sent_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldValidationSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationSentAt: %w", err)
	}
	return oldValue.ValidationSentAt, nil
}

// ResetValidationSentAt resets all changes to the "validation_sent_at" field.
func (m *UserMutation) ResetValidationSentAt() {
	m.validation_sent_at = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetPasswordResetKey sets the "password_reset_key" field.
func (m *UserMutation) SetPasswordResetKey(u uuid.UUID) {
	m.password_reset_key = &u
}

// PasswordResetKey returns the value of the "password_reset_key" field in the mutation.
func (m *UserMutation) PasswordResetKey() (r uuid.UUID, exists bool) {
	v := m.password_reset_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordResetKey returns the old "password_reset_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordResetKey(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordResetKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordResetKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordResetKey: %w", err)
	}
	return oldValue.PasswordResetKey, nil
}

// ResetPasswordResetKey resets all changes to the "password_reset_key" field.
func (m *UserMutation) ResetPasswordResetKey() {
	m.password_reset_key = nil
}

// SetPasswordResetAt sets the "password_reset_at" field.
func (m *UserMutation) SetPasswordResetAt(t time.Time) {
	m.password_reset_at = &t
}

// PasswordResetAt returns the value of the "password_reset_at" field in the mutation.
func (m *UserMutation) PasswordResetAt() (r time.Time, exists bool) {
	v := m.password_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordResetAt returns the old "password_reset_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordResetAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordResetAt: %w", err)
	}
	return oldValue.PasswordResetAt, nil
}

// ResetPasswordResetAt resets all changes to the "password_reset_at" field.
func (m *UserMutation) ResetPasswordResetAt() {
	m.password_reset_at = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *UserMutation) SetRoleID(id uuid.UUID) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *UserMutation) RoleID() (id uuid.UUID, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// AddProjectAssignmentIDs adds the "projectAssignments" edge to the ProjectAssignment entity by ids.
func (m *UserMutation) AddProjectAssignmentIDs(ids ...uuid.UUID) {
	if m.projectAssignments == nil {
		m.projectAssignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.projectAssignments[ids[i]] = struct{}{}
	}
}

// ClearProjectAssignments clears the "projectAssignments" edge to the ProjectAssignment entity.
func (m *UserMutation) ClearProjectAssignments() {
	m.clearedprojectAssignments = true
}

// ProjectAssignmentsCleared reports if the "projectAssignments" edge to the ProjectAssignment entity was cleared.
func (m *UserMutation) ProjectAssignmentsCleared() bool {
	return m.clearedprojectAssignments
}

// RemoveProjectAssignmentIDs removes the "projectAssignments" edge to the ProjectAssignment entity by IDs.
func (m *UserMutation) RemoveProjectAssignmentIDs(ids ...uuid.UUID) {
	if m.removedprojectAssignments == nil {
		m.removedprojectAssignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.projectAssignments, ids[i])
		m.removedprojectAssignments[ids[i]] = struct{}{}
	}
}

// RemovedProjectAssignments returns the removed IDs of the "projectAssignments" edge to the ProjectAssignment entity.
func (m *UserMutation) RemovedProjectAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedprojectAssignments {
		ids = append(ids, id)
	}
	return
}

// ProjectAssignmentsIDs returns the "projectAssignments" edge IDs in the mutation.
func (m *UserMutation) ProjectAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.projectAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetProjectAssignments resets all changes to the "projectAssignments" edge.
func (m *UserMutation) ResetProjectAssignments() {
	m.projectAssignments = nil
	m.clearedprojectAssignments = false
	m.removedprojectAssignments = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *UserMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *UserMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *UserMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *UserMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *UserMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *UserMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *UserMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddCameraIDs adds the "cameras" edge to the Camera entity by ids.
func (m *UserMutation) AddCameraIDs(ids ...uuid.UUID) {
	if m.cameras == nil {
		m.cameras = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cameras[ids[i]] = struct{}{}
	}
}

// ClearCameras clears the "cameras" edge to the Camera entity.
func (m *UserMutation) ClearCameras() {
	m.clearedcameras = true
}

// CamerasCleared reports if the "cameras" edge to the Camera entity was cleared.
func (m *UserMutation) CamerasCleared() bool {
	return m.clearedcameras
}

// RemoveCameraIDs removes the "cameras" edge to the Camera entity by IDs.
func (m *UserMutation) RemoveCameraIDs(ids ...uuid.UUID) {
	if m.removedcameras == nil {
		m.removedcameras = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cameras, ids[i])
		m.removedcameras[ids[i]] = struct{}{}
	}
}

// RemovedCameras returns the removed IDs of the "cameras" edge to the Camera entity.
func (m *UserMutation) RemovedCamerasIDs() (ids []uuid.UUID) {
	for id := range m.removedcameras {
		ids = append(ids, id)
	}
	return
}

// CamerasIDs returns the "cameras" edge IDs in the mutation.
func (m *UserMutation) CamerasIDs() (ids []uuid.UUID) {
	for id := range m.cameras {
		ids = append(ids, id)
	}
	return
}

// ResetCameras resets all changes to the "cameras" edge.
func (m *UserMutation) ResetCameras() {
	m.cameras = nil
	m.clearedcameras = false
	m.removedcameras = nil
}

// AddApiKeyIDs adds the "apiKey" edge to the ApiKey entity by ids.
func (m *UserMutation) AddApiKeyIDs(ids ...uuid.UUID) {
	if m.apiKey == nil {
		m.apiKey = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.apiKey[ids[i]] = struct{}{}
	}
}

// ClearApiKey clears the "apiKey" edge to the ApiKey entity.
func (m *UserMutation) ClearApiKey() {
	m.clearedapiKey = true
}

// ApiKeyCleared reports if the "apiKey" edge to the ApiKey entity was cleared.
func (m *UserMutation) ApiKeyCleared() bool {
	return m.clearedapiKey
}

// RemoveApiKeyIDs removes the "apiKey" edge to the ApiKey entity by IDs.
func (m *UserMutation) RemoveApiKeyIDs(ids ...uuid.UUID) {
	if m.removedapiKey == nil {
		m.removedapiKey = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.apiKey, ids[i])
		m.removedapiKey[ids[i]] = struct{}{}
	}
}

// RemovedApiKey returns the removed IDs of the "apiKey" edge to the ApiKey entity.
func (m *UserMutation) RemovedApiKeyIDs() (ids []uuid.UUID) {
	for id := range m.removedapiKey {
		ids = append(ids, id)
	}
	return
}

// ApiKeyIDs returns the "apiKey" edge IDs in the mutation.
func (m *UserMutation) ApiKeyIDs() (ids []uuid.UUID) {
	for id := range m.apiKey {
		ids = append(ids, id)
	}
	return
}

// ResetApiKey resets all changes to the "apiKey" edge.
func (m *UserMutation) ResetApiKey() {
	m.apiKey = nil
	m.clearedapiKey = false
	m.removedapiKey = nil
}

// AddCreatedUserIDs adds the "created_users" edge to the User entity by ids.
func (m *UserMutation) AddCreatedUserIDs(ids ...uuid.UUID) {
	if m.created_users == nil {
		m.created_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_users[ids[i]] = struct{}{}
	}
}

// ClearCreatedUsers clears the "created_users" edge to the User entity.
func (m *UserMutation) ClearCreatedUsers() {
	m.clearedcreated_users = true
}

// CreatedUsersCleared reports if the "created_users" edge to the User entity was cleared.
func (m *UserMutation) CreatedUsersCleared() bool {
	return m.clearedcreated_users
}

// RemoveCreatedUserIDs removes the "created_users" edge to the User entity by IDs.
func (m *UserMutation) RemoveCreatedUserIDs(ids ...uuid.UUID) {
	if m.removedcreated_users == nil {
		m.removedcreated_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_users, ids[i])
		m.removedcreated_users[ids[i]] = struct{}{}
	}
}

// RemovedCreatedUsers returns the removed IDs of the "created_users" edge to the User entity.
func (m *UserMutation) RemovedCreatedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_users {
		ids = append(ids, id)
	}
	return
}

// CreatedUsersIDs returns the "created_users" edge IDs in the mutation.
func (m *UserMutation) CreatedUsersIDs() (ids []uuid.UUID) {
	for id := range m.created_users {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedUsers resets all changes to the "created_users" edge.
func (m *UserMutation) ResetCreatedUsers() {
	m.created_users = nil
	m.clearedcreated_users = false
	m.removedcreated_users = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *UserMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *UserMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *UserMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *UserMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddModifiedUserIDs adds the "modified_users" edge to the User entity by ids.
func (m *UserMutation) AddModifiedUserIDs(ids ...uuid.UUID) {
	if m.modified_users == nil {
		m.modified_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.modified_users[ids[i]] = struct{}{}
	}
}

// ClearModifiedUsers clears the "modified_users" edge to the User entity.
func (m *UserMutation) ClearModifiedUsers() {
	m.clearedmodified_users = true
}

// ModifiedUsersCleared reports if the "modified_users" edge to the User entity was cleared.
func (m *UserMutation) ModifiedUsersCleared() bool {
	return m.clearedmodified_users
}

// RemoveModifiedUserIDs removes the "modified_users" edge to the User entity by IDs.
func (m *UserMutation) RemoveModifiedUserIDs(ids ...uuid.UUID) {
	if m.removedmodified_users == nil {
		m.removedmodified_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.modified_users, ids[i])
		m.removedmodified_users[ids[i]] = struct{}{}
	}
}

// RemovedModifiedUsers returns the removed IDs of the "modified_users" edge to the User entity.
func (m *UserMutation) RemovedModifiedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedmodified_users {
		ids = append(ids, id)
	}
	return
}

// ModifiedUsersIDs returns the "modified_users" edge IDs in the mutation.
func (m *UserMutation) ModifiedUsersIDs() (ids []uuid.UUID) {
	for id := range m.modified_users {
		ids = append(ids, id)
	}
	return
}

// ResetModifiedUsers resets all changes to the "modified_users" edge.
func (m *UserMutation) ResetModifiedUsers() {
	m.modified_users = nil
	m.clearedmodified_users = false
	m.removedmodified_users = nil
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *UserMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *UserMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *UserMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *UserMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.copyright_tag != nil {
		fields = append(fields, user.FieldCopyrightTag)
	}
	if m.email_validated != nil {
		fields = append(fields, user.FieldEmailValidated)
	}
	if m.validation_key != nil {
		fields = append(fields, user.FieldValidationKey)
	}
	if m.validation_sent_at != nil {
		fields = append(fields, user.FieldValidationSentAt)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.password_reset_key != nil {
		fields = append(fields, user.FieldPasswordResetKey)
	}
	if m.password_reset_at != nil {
		fields = append(fields, user.FieldPasswordResetAt)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldCopyrightTag:
		return m.CopyrightTag()
	case user.FieldEmailValidated:
		return m.EmailValidated()
	case user.FieldValidationKey:
		return m.ValidationKey()
	case user.FieldValidationSentAt:
		return m.ValidationSentAt()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPasswordResetKey:
		return m.PasswordResetKey()
	case user.FieldPasswordResetAt:
		return m.PasswordResetAt()
	case user.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldCopyrightTag:
		return m.OldCopyrightTag(ctx)
	case user.FieldEmailValidated:
		return m.OldEmailValidated(ctx)
	case user.FieldValidationKey:
		return m.OldValidationKey(ctx)
	case user.FieldValidationSentAt:
		return m.OldValidationSentAt(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPasswordResetKey:
		return m.OldPasswordResetKey(ctx)
	case user.FieldPasswordResetAt:
		return m.OldPasswordResetAt(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldCopyrightTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyrightTag(v)
		return nil
	case user.FieldEmailValidated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailValidated(v)
		return nil
	case user.FieldValidationKey:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationKey(v)
		return nil
	case user.FieldValidationSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationSentAt(v)
		return nil
	case user.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPasswordResetKey:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordResetKey(v)
		return nil
	case user.FieldPasswordResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordResetAt(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldCopyrightTag:
		m.ResetCopyrightTag()
		return nil
	case user.FieldEmailValidated:
		m.ResetEmailValidated()
		return nil
	case user.FieldValidationKey:
		m.ResetValidationKey()
		return nil
	case user.FieldValidationSentAt:
		m.ResetValidationSentAt()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPasswordResetKey:
		m.ResetPasswordResetKey()
		return nil
	case user.FieldPasswordResetAt:
		m.ResetPasswordResetAt()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.role != nil {
		edges = append(edges, user.EdgeRole)
	}
	if m.projectAssignments != nil {
		edges = append(edges, user.EdgeProjectAssignments)
	}
	if m.images != nil {
		edges = append(edges, user.EdgeImages)
	}
	if m.cameras != nil {
		edges = append(edges, user.EdgeCameras)
	}
	if m.apiKey != nil {
		edges = append(edges, user.EdgeApiKey)
	}
	if m.created_users != nil {
		edges = append(edges, user.EdgeCreatedUsers)
	}
	if m.created_by != nil {
		edges = append(edges, user.EdgeCreatedBy)
	}
	if m.modified_users != nil {
		edges = append(edges, user.EdgeModifiedUsers)
	}
	if m.updated_by != nil {
		edges = append(edges, user.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeProjectAssignments:
		ids := make([]ent.Value, 0, len(m.projectAssignments))
		for id := range m.projectAssignments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCameras:
		ids := make([]ent.Value, 0, len(m.cameras))
		for id := range m.cameras {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApiKey:
		ids := make([]ent.Value, 0, len(m.apiKey))
		for id := range m.apiKey {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUsers:
		ids := make([]ent.Value, 0, len(m.created_users))
		for id := range m.created_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeModifiedUsers:
		ids := make([]ent.Value, 0, len(m.modified_users))
		for id := range m.modified_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedprojectAssignments != nil {
		edges = append(edges, user.EdgeProjectAssignments)
	}
	if m.removedimages != nil {
		edges = append(edges, user.EdgeImages)
	}
	if m.removedcameras != nil {
		edges = append(edges, user.EdgeCameras)
	}
	if m.removedapiKey != nil {
		edges = append(edges, user.EdgeApiKey)
	}
	if m.removedcreated_users != nil {
		edges = append(edges, user.EdgeCreatedUsers)
	}
	if m.removedmodified_users != nil {
		edges = append(edges, user.EdgeModifiedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjectAssignments:
		ids := make([]ent.Value, 0, len(m.removedprojectAssignments))
		for id := range m.removedprojectAssignments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCameras:
		ids := make([]ent.Value, 0, len(m.removedcameras))
		for id := range m.removedcameras {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApiKey:
		ids := make([]ent.Value, 0, len(m.removedapiKey))
		for id := range m.removedapiKey {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUsers:
		ids := make([]ent.Value, 0, len(m.removedcreated_users))
		for id := range m.removedcreated_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModifiedUsers:
		ids := make([]ent.Value, 0, len(m.removedmodified_users))
		for id := range m.removedmodified_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedrole {
		edges = append(edges, user.EdgeRole)
	}
	if m.clearedprojectAssignments {
		edges = append(edges, user.EdgeProjectAssignments)
	}
	if m.clearedimages {
		edges = append(edges, user.EdgeImages)
	}
	if m.clearedcameras {
		edges = append(edges, user.EdgeCameras)
	}
	if m.clearedapiKey {
		edges = append(edges, user.EdgeApiKey)
	}
	if m.clearedcreated_users {
		edges = append(edges, user.EdgeCreatedUsers)
	}
	if m.clearedcreated_by {
		edges = append(edges, user.EdgeCreatedBy)
	}
	if m.clearedmodified_users {
		edges = append(edges, user.EdgeModifiedUsers)
	}
	if m.clearedupdated_by {
		edges = append(edges, user.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRole:
		return m.clearedrole
	case user.EdgeProjectAssignments:
		return m.clearedprojectAssignments
	case user.EdgeImages:
		return m.clearedimages
	case user.EdgeCameras:
		return m.clearedcameras
	case user.EdgeApiKey:
		return m.clearedapiKey
	case user.EdgeCreatedUsers:
		return m.clearedcreated_users
	case user.EdgeCreatedBy:
		return m.clearedcreated_by
	case user.EdgeModifiedUsers:
		return m.clearedmodified_users
	case user.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ClearRole()
		return nil
	case user.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case user.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ResetRole()
		return nil
	case user.EdgeProjectAssignments:
		m.ResetProjectAssignments()
		return nil
	case user.EdgeImages:
		m.ResetImages()
		return nil
	case user.EdgeCameras:
		m.ResetCameras()
		return nil
	case user.EdgeApiKey:
		m.ResetApiKey()
		return nil
	case user.EdgeCreatedUsers:
		m.ResetCreatedUsers()
		return nil
	case user.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.EdgeModifiedUsers:
		m.ResetModifiedUsers()
		return nil
	case user.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
