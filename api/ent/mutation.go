// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/shutterbase/shutterbase/ent/camera"
	"github.com/shutterbase/shutterbase/ent/image"
	"github.com/shutterbase/shutterbase/ent/imagetag"
	"github.com/shutterbase/shutterbase/ent/predicate"
	"github.com/shutterbase/shutterbase/ent/project"
	"github.com/shutterbase/shutterbase/ent/projectassignment"
	"github.com/shutterbase/shutterbase/ent/role"
	"github.com/shutterbase/shutterbase/ent/timeoffset"
	"github.com/shutterbase/shutterbase/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCamera            = "Camera"
	TypeImage             = "Image"
	TypeImageTag          = "ImageTag"
	TypeProject           = "Project"
	TypeProjectAssignment = "ProjectAssignment"
	TypeRole              = "Role"
	TypeTimeOffset        = "TimeOffset"
	TypeUser              = "User"
)

// CameraMutation represents an operation that mutates the Camera nodes in the graph.
type CameraMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	description        *string
	clearedFields      map[string]struct{}
	timeOffsets        map[uuid.UUID]struct{}
	removedtimeOffsets map[uuid.UUID]struct{}
	clearedtimeOffsets bool
	images             map[uuid.UUID]struct{}
	removedimages      map[uuid.UUID]struct{}
	clearedimages      bool
	owner              *uuid.UUID
	clearedowner       bool
	created_by         *uuid.UUID
	clearedcreated_by  bool
	updated_by         *uuid.UUID
	clearedupdated_by  bool
	done               bool
	oldValue           func(context.Context) (*Camera, error)
	predicates         []predicate.Camera
}

var _ ent.Mutation = (*CameraMutation)(nil)

// cameraOption allows management of the mutation configuration using functional options.
type cameraOption func(*CameraMutation)

// newCameraMutation creates new mutation for the Camera entity.
func newCameraMutation(c config, op Op, opts ...cameraOption) *CameraMutation {
	m := &CameraMutation{
		config:        c,
		op:            op,
		typ:           TypeCamera,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCameraID sets the ID field of the mutation.
func withCameraID(id uuid.UUID) cameraOption {
	return func(m *CameraMutation) {
		var (
			err   error
			once  sync.Once
			value *Camera
		)
		m.oldValue = func(ctx context.Context) (*Camera, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Camera.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCamera sets the old Camera of the mutation.
func withCamera(node *Camera) cameraOption {
	return func(m *CameraMutation) {
		m.oldValue = func(context.Context) (*Camera, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CameraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CameraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Camera entities.
func (m *CameraMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CameraMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CameraMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Camera.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CameraMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CameraMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CameraMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CameraMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CameraMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CameraMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CameraMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CameraMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CameraMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CameraMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CameraMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CameraMutation) ResetDescription() {
	m.description = nil
}

// AddTimeOffsetIDs adds the "timeOffsets" edge to the TimeOffset entity by ids.
func (m *CameraMutation) AddTimeOffsetIDs(ids ...uuid.UUID) {
	if m.timeOffsets == nil {
		m.timeOffsets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.timeOffsets[ids[i]] = struct{}{}
	}
}

// ClearTimeOffsets clears the "timeOffsets" edge to the TimeOffset entity.
func (m *CameraMutation) ClearTimeOffsets() {
	m.clearedtimeOffsets = true
}

// TimeOffsetsCleared reports if the "timeOffsets" edge to the TimeOffset entity was cleared.
func (m *CameraMutation) TimeOffsetsCleared() bool {
	return m.clearedtimeOffsets
}

// RemoveTimeOffsetIDs removes the "timeOffsets" edge to the TimeOffset entity by IDs.
func (m *CameraMutation) RemoveTimeOffsetIDs(ids ...uuid.UUID) {
	if m.removedtimeOffsets == nil {
		m.removedtimeOffsets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.timeOffsets, ids[i])
		m.removedtimeOffsets[ids[i]] = struct{}{}
	}
}

// RemovedTimeOffsets returns the removed IDs of the "timeOffsets" edge to the TimeOffset entity.
func (m *CameraMutation) RemovedTimeOffsetsIDs() (ids []uuid.UUID) {
	for id := range m.removedtimeOffsets {
		ids = append(ids, id)
	}
	return
}

// TimeOffsetsIDs returns the "timeOffsets" edge IDs in the mutation.
func (m *CameraMutation) TimeOffsetsIDs() (ids []uuid.UUID) {
	for id := range m.timeOffsets {
		ids = append(ids, id)
	}
	return
}

// ResetTimeOffsets resets all changes to the "timeOffsets" edge.
func (m *CameraMutation) ResetTimeOffsets() {
	m.timeOffsets = nil
	m.clearedtimeOffsets = false
	m.removedtimeOffsets = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *CameraMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *CameraMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *CameraMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *CameraMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *CameraMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *CameraMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *CameraMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CameraMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CameraMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CameraMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CameraMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CameraMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CameraMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *CameraMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *CameraMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *CameraMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *CameraMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *CameraMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *CameraMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *CameraMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *CameraMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *CameraMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *CameraMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *CameraMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *CameraMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the CameraMutation builder.
func (m *CameraMutation) Where(ps ...predicate.Camera) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CameraMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CameraMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Camera, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CameraMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CameraMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Camera).
func (m *CameraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CameraMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, camera.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, camera.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, camera.FieldName)
	}
	if m.description != nil {
		fields = append(fields, camera.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CameraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case camera.FieldCreatedAt:
		return m.CreatedAt()
	case camera.FieldUpdatedAt:
		return m.UpdatedAt()
	case camera.FieldName:
		return m.Name()
	case camera.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CameraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case camera.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case camera.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case camera.FieldName:
		return m.OldName(ctx)
	case camera.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Camera field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case camera.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case camera.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case camera.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case camera.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CameraMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CameraMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Camera numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CameraMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CameraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CameraMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Camera nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CameraMutation) ResetField(name string) error {
	switch name {
	case camera.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case camera.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case camera.FieldName:
		m.ResetName()
		return nil
	case camera.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CameraMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.timeOffsets != nil {
		edges = append(edges, camera.EdgeTimeOffsets)
	}
	if m.images != nil {
		edges = append(edges, camera.EdgeImages)
	}
	if m.owner != nil {
		edges = append(edges, camera.EdgeOwner)
	}
	if m.created_by != nil {
		edges = append(edges, camera.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, camera.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CameraMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeTimeOffsets:
		ids := make([]ent.Value, 0, len(m.timeOffsets))
		for id := range m.timeOffsets {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case camera.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case camera.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CameraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtimeOffsets != nil {
		edges = append(edges, camera.EdgeTimeOffsets)
	}
	if m.removedimages != nil {
		edges = append(edges, camera.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CameraMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeTimeOffsets:
		ids := make([]ent.Value, 0, len(m.removedtimeOffsets))
		for id := range m.removedtimeOffsets {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CameraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtimeOffsets {
		edges = append(edges, camera.EdgeTimeOffsets)
	}
	if m.clearedimages {
		edges = append(edges, camera.EdgeImages)
	}
	if m.clearedowner {
		edges = append(edges, camera.EdgeOwner)
	}
	if m.clearedcreated_by {
		edges = append(edges, camera.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, camera.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CameraMutation) EdgeCleared(name string) bool {
	switch name {
	case camera.EdgeTimeOffsets:
		return m.clearedtimeOffsets
	case camera.EdgeImages:
		return m.clearedimages
	case camera.EdgeOwner:
		return m.clearedowner
	case camera.EdgeCreatedBy:
		return m.clearedcreated_by
	case camera.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CameraMutation) ClearEdge(name string) error {
	switch name {
	case camera.EdgeOwner:
		m.ClearOwner()
		return nil
	case camera.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case camera.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Camera unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CameraMutation) ResetEdge(name string) error {
	switch name {
	case camera.EdgeTimeOffsets:
		m.ResetTimeOffsets()
		return nil
	case camera.EdgeImages:
		m.ResetImages()
		return nil
	case camera.EdgeOwner:
		m.ResetOwner()
		return nil
	case camera.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case camera.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Camera edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	file_name         *string
	description       *string
	exif_data         *map[string]interface{}
	clearedFields     map[string]struct{}
	tags              map[uuid.UUID]struct{}
	removedtags       map[uuid.UUID]struct{}
	clearedtags       bool
	user              *uuid.UUID
	cleareduser       bool
	project           *uuid.UUID
	clearedproject    bool
	camera            *uuid.UUID
	clearedcamera     bool
	created_by        *uuid.UUID
	clearedcreated_by bool
	updated_by        *uuid.UUID
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*Image, error)
	predicates        []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id uuid.UUID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFileName sets the "file_name" field.
func (m *ImageMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *ImageMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *ImageMutation) ResetFileName() {
	m.file_name = nil
}

// SetDescription sets the "description" field.
func (m *ImageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ImageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ImageMutation) ResetDescription() {
	m.description = nil
}

// SetExifData sets the "exif_data" field.
func (m *ImageMutation) SetExifData(value map[string]interface{}) {
	m.exif_data = &value
}

// ExifData returns the value of the "exif_data" field in the mutation.
func (m *ImageMutation) ExifData() (r map[string]interface{}, exists bool) {
	v := m.exif_data
	if v == nil {
		return
	}
	return *v, true
}

// OldExifData returns the old "exif_data" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldExifData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExifData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExifData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExifData: %w", err)
	}
	return oldValue.ExifData, nil
}

// ResetExifData resets all changes to the "exif_data" field.
func (m *ImageMutation) ResetExifData() {
	m.exif_data = nil
}

// AddTagIDs adds the "tags" edge to the ImageTag entity by ids.
func (m *ImageMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the ImageTag entity.
func (m *ImageMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the ImageTag entity was cleared.
func (m *ImageMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the ImageTag entity by IDs.
func (m *ImageMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the ImageTag entity.
func (m *ImageMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ImageMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ImageMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ImageMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ImageMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ImageMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ImageMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ImageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ImageMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ImageMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ImageMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ImageMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ImageMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetCameraID sets the "camera" edge to the Camera entity by id.
func (m *ImageMutation) SetCameraID(id uuid.UUID) {
	m.camera = &id
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *ImageMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *ImageMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraID returns the "camera" edge ID in the mutation.
func (m *ImageMutation) CameraID() (id uuid.UUID, exists bool) {
	if m.camera != nil {
		return *m.camera, true
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) CameraIDs() (ids []uuid.UUID) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *ImageMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ImageMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ImageMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ImageMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ImageMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ImageMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ImageMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ImageMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ImageMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ImageMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ImageMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, image.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, image.FieldUpdatedAt)
	}
	if m.file_name != nil {
		fields = append(fields, image.FieldFileName)
	}
	if m.description != nil {
		fields = append(fields, image.FieldDescription)
	}
	if m.exif_data != nil {
		fields = append(fields, image.FieldExifData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldCreatedAt:
		return m.CreatedAt()
	case image.FieldUpdatedAt:
		return m.UpdatedAt()
	case image.FieldFileName:
		return m.FileName()
	case image.FieldDescription:
		return m.Description()
	case image.FieldExifData:
		return m.ExifData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case image.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case image.FieldFileName:
		return m.OldFileName(ctx)
	case image.FieldDescription:
		return m.OldDescription(ctx)
	case image.FieldExifData:
		return m.OldExifData(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case image.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case image.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case image.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case image.FieldExifData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExifData(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case image.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case image.FieldFileName:
		m.ResetFileName()
		return nil
	case image.FieldDescription:
		m.ResetDescription()
		return nil
	case image.FieldExifData:
		m.ResetExifData()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.tags != nil {
		edges = append(edges, image.EdgeTags)
	}
	if m.user != nil {
		edges = append(edges, image.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, image.EdgeProject)
	}
	if m.camera != nil {
		edges = append(edges, image.EdgeCamera)
	}
	if m.created_by != nil {
		edges = append(edges, image.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, image.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case image.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtags != nil {
		edges = append(edges, image.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtags {
		edges = append(edges, image.EdgeTags)
	}
	if m.cleareduser {
		edges = append(edges, image.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, image.EdgeProject)
	}
	if m.clearedcamera {
		edges = append(edges, image.EdgeCamera)
	}
	if m.clearedcreated_by {
		edges = append(edges, image.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, image.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeTags:
		return m.clearedtags
	case image.EdgeUser:
		return m.cleareduser
	case image.EdgeProject:
		return m.clearedproject
	case image.EdgeCamera:
		return m.clearedcamera
	case image.EdgeCreatedBy:
		return m.clearedcreated_by
	case image.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeUser:
		m.ClearUser()
		return nil
	case image.EdgeProject:
		m.ClearProject()
		return nil
	case image.EdgeCamera:
		m.ClearCamera()
		return nil
	case image.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case image.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeTags:
		m.ResetTags()
		return nil
	case image.EdgeUser:
		m.ResetUser()
		return nil
	case image.EdgeProject:
		m.ResetProject()
		return nil
	case image.EdgeCamera:
		m.ResetCamera()
		return nil
	case image.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case image.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// ImageTagMutation represents an operation that mutates the ImageTag nodes in the graph.
type ImageTagMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	description       *string
	is_album          *bool
	clearedFields     map[string]struct{}
	project           *uuid.UUID
	clearedproject    bool
	images            map[uuid.UUID]struct{}
	removedimages     map[uuid.UUID]struct{}
	clearedimages     bool
	created_by        *uuid.UUID
	clearedcreated_by bool
	updated_by        *uuid.UUID
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*ImageTag, error)
	predicates        []predicate.ImageTag
}

var _ ent.Mutation = (*ImageTagMutation)(nil)

// imagetagOption allows management of the mutation configuration using functional options.
type imagetagOption func(*ImageTagMutation)

// newImageTagMutation creates new mutation for the ImageTag entity.
func newImageTagMutation(c config, op Op, opts ...imagetagOption) *ImageTagMutation {
	m := &ImageTagMutation{
		config:        c,
		op:            op,
		typ:           TypeImageTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageTagID sets the ID field of the mutation.
func withImageTagID(id uuid.UUID) imagetagOption {
	return func(m *ImageTagMutation) {
		var (
			err   error
			once  sync.Once
			value *ImageTag
		)
		m.oldValue = func(ctx context.Context) (*ImageTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImageTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImageTag sets the old ImageTag of the mutation.
func withImageTag(node *ImageTag) imagetagOption {
	return func(m *ImageTagMutation) {
		m.oldValue = func(context.Context) (*ImageTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ImageTag entities.
func (m *ImageTagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageTagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageTagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImageTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ImageTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImageTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImageTagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ImageTagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ImageTagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ImageTagMutation) ResetDescription() {
	m.description = nil
}

// SetIsAlbum sets the "is_album" field.
func (m *ImageTagMutation) SetIsAlbum(b bool) {
	m.is_album = &b
}

// IsAlbum returns the value of the "is_album" field in the mutation.
func (m *ImageTagMutation) IsAlbum() (r bool, exists bool) {
	v := m.is_album
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAlbum returns the old "is_album" field's value of the ImageTag entity.
// If the ImageTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageTagMutation) OldIsAlbum(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAlbum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAlbum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAlbum: %w", err)
	}
	return oldValue.IsAlbum, nil
}

// ResetIsAlbum resets all changes to the "is_album" field.
func (m *ImageTagMutation) ResetIsAlbum() {
	m.is_album = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ImageTagMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ImageTagMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ImageTagMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ImageTagMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ImageTagMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ImageTagMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *ImageTagMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *ImageTagMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *ImageTagMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *ImageTagMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *ImageTagMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ImageTagMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ImageTagMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ImageTagMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ImageTagMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ImageTagMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ImageTagMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ImageTagMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ImageTagMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ImageTagMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ImageTagMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ImageTagMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ImageTagMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ImageTagMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ImageTagMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the ImageTagMutation builder.
func (m *ImageTagMutation) Where(ps ...predicate.ImageTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImageTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImageTag).
func (m *ImageTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageTagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, imagetag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, imagetag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, imagetag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, imagetag.FieldDescription)
	}
	if m.is_album != nil {
		fields = append(fields, imagetag.FieldIsAlbum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case imagetag.FieldCreatedAt:
		return m.CreatedAt()
	case imagetag.FieldUpdatedAt:
		return m.UpdatedAt()
	case imagetag.FieldName:
		return m.Name()
	case imagetag.FieldDescription:
		return m.Description()
	case imagetag.FieldIsAlbum:
		return m.IsAlbum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case imagetag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case imagetag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case imagetag.FieldName:
		return m.OldName(ctx)
	case imagetag.FieldDescription:
		return m.OldDescription(ctx)
	case imagetag.FieldIsAlbum:
		return m.OldIsAlbum(ctx)
	}
	return nil, fmt.Errorf("unknown ImageTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case imagetag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case imagetag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case imagetag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case imagetag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case imagetag.FieldIsAlbum:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAlbum(v)
		return nil
	}
	return fmt.Errorf("unknown ImageTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImageTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ImageTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageTagMutation) ResetField(name string) error {
	switch name {
	case imagetag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case imagetag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case imagetag.FieldName:
		m.ResetName()
		return nil
	case imagetag.FieldDescription:
		m.ResetDescription()
		return nil
	case imagetag.FieldIsAlbum:
		m.ResetIsAlbum()
		return nil
	}
	return fmt.Errorf("unknown ImageTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.project != nil {
		edges = append(edges, imagetag.EdgeProject)
	}
	if m.images != nil {
		edges = append(edges, imagetag.EdgeImages)
	}
	if m.created_by != nil {
		edges = append(edges, imagetag.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, imagetag.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case imagetag.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case imagetag.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case imagetag.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case imagetag.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedimages != nil {
		edges = append(edges, imagetag.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case imagetag.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproject {
		edges = append(edges, imagetag.EdgeProject)
	}
	if m.clearedimages {
		edges = append(edges, imagetag.EdgeImages)
	}
	if m.clearedcreated_by {
		edges = append(edges, imagetag.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, imagetag.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageTagMutation) EdgeCleared(name string) bool {
	switch name {
	case imagetag.EdgeProject:
		return m.clearedproject
	case imagetag.EdgeImages:
		return m.clearedimages
	case imagetag.EdgeCreatedBy:
		return m.clearedcreated_by
	case imagetag.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageTagMutation) ClearEdge(name string) error {
	switch name {
	case imagetag.EdgeProject:
		m.ClearProject()
		return nil
	case imagetag.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case imagetag.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ImageTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageTagMutation) ResetEdge(name string) error {
	switch name {
	case imagetag.EdgeProject:
		m.ResetProject()
		return nil
	case imagetag.EdgeImages:
		m.ResetImages()
		return nil
	case imagetag.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case imagetag.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ImageTag edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	description        *string
	clearedFields      map[string]struct{}
	assignments        map[uuid.UUID]struct{}
	removedassignments map[uuid.UUID]struct{}
	clearedassignments bool
	images             map[uuid.UUID]struct{}
	removedimages      map[uuid.UUID]struct{}
	clearedimages      bool
	tags               map[uuid.UUID]struct{}
	removedtags        map[uuid.UUID]struct{}
	clearedtags        bool
	created_by         *uuid.UUID
	clearedcreated_by  bool
	updated_by         *uuid.UUID
	clearedupdated_by  bool
	done               bool
	oldValue           func(context.Context) (*Project, error)
	predicates         []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id uuid.UUID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// AddAssignmentIDs adds the "assignments" edge to the ProjectAssignment entity by ids.
func (m *ProjectMutation) AddAssignmentIDs(ids ...uuid.UUID) {
	if m.assignments == nil {
		m.assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the ProjectAssignment entity.
func (m *ProjectMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the ProjectAssignment entity was cleared.
func (m *ProjectMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the ProjectAssignment entity by IDs.
func (m *ProjectMutation) RemoveAssignmentIDs(ids ...uuid.UUID) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the ProjectAssignment entity.
func (m *ProjectMutation) RemovedAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *ProjectMutation) AssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *ProjectMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *ProjectMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *ProjectMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *ProjectMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *ProjectMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *ProjectMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ProjectMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ProjectMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddTagIDs adds the "tags" edge to the ImageTag entity by ids.
func (m *ProjectMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the ImageTag entity.
func (m *ProjectMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the ImageTag entity was cleared.
func (m *ProjectMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the ImageTag entity by IDs.
func (m *ProjectMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the ImageTag entity.
func (m *ProjectMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ProjectMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProjectMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ProjectMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ProjectMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ProjectMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ProjectMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ProjectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ProjectMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ProjectMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ProjectMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ProjectMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ProjectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.assignments != nil {
		edges = append(edges, project.EdgeAssignments)
	}
	if m.images != nil {
		edges = append(edges, project.EdgeImages)
	}
	if m.tags != nil {
		edges = append(edges, project.EdgeTags)
	}
	if m.created_by != nil {
		edges = append(edges, project.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, project.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedassignments != nil {
		edges = append(edges, project.EdgeAssignments)
	}
	if m.removedimages != nil {
		edges = append(edges, project.EdgeImages)
	}
	if m.removedtags != nil {
		edges = append(edges, project.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedassignments {
		edges = append(edges, project.EdgeAssignments)
	}
	if m.clearedimages {
		edges = append(edges, project.EdgeImages)
	}
	if m.clearedtags {
		edges = append(edges, project.EdgeTags)
	}
	if m.clearedcreated_by {
		edges = append(edges, project.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, project.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeAssignments:
		return m.clearedassignments
	case project.EdgeImages:
		return m.clearedimages
	case project.EdgeTags:
		return m.clearedtags
	case project.EdgeCreatedBy:
		return m.clearedcreated_by
	case project.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case project.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeAssignments:
		m.ResetAssignments()
		return nil
	case project.EdgeImages:
		m.ResetImages()
		return nil
	case project.EdgeTags:
		m.ResetTags()
		return nil
	case project.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case project.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectAssignmentMutation represents an operation that mutates the ProjectAssignment nodes in the graph.
type ProjectAssignmentMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	project           *uuid.UUID
	clearedproject    bool
	role              *uuid.UUID
	clearedrole       bool
	created_by        *uuid.UUID
	clearedcreated_by bool
	updated_by        *uuid.UUID
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*ProjectAssignment, error)
	predicates        []predicate.ProjectAssignment
}

var _ ent.Mutation = (*ProjectAssignmentMutation)(nil)

// projectassignmentOption allows management of the mutation configuration using functional options.
type projectassignmentOption func(*ProjectAssignmentMutation)

// newProjectAssignmentMutation creates new mutation for the ProjectAssignment entity.
func newProjectAssignmentMutation(c config, op Op, opts ...projectassignmentOption) *ProjectAssignmentMutation {
	m := &ProjectAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectAssignmentID sets the ID field of the mutation.
func withProjectAssignmentID(id uuid.UUID) projectassignmentOption {
	return func(m *ProjectAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectAssignment
		)
		m.oldValue = func(ctx context.Context) (*ProjectAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectAssignment sets the old ProjectAssignment of the mutation.
func withProjectAssignment(node *ProjectAssignment) projectassignmentOption {
	return func(m *ProjectAssignmentMutation) {
		m.oldValue = func(context.Context) (*ProjectAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectAssignment entities.
func (m *ProjectAssignmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectAssignmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectAssignmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectAssignment entity.
// If the ProjectAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectAssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectAssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectAssignment entity.
// If the ProjectAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectAssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectAssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProjectAssignmentMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProjectAssignmentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProjectAssignmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProjectAssignmentMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProjectAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectAssignmentMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectAssignmentMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectAssignmentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectAssignmentMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectAssignmentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *ProjectAssignmentMutation) SetRoleID(id uuid.UUID) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *ProjectAssignmentMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *ProjectAssignmentMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *ProjectAssignmentMutation) RoleID() (id uuid.UUID, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *ProjectAssignmentMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ProjectAssignmentMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ProjectAssignmentMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ProjectAssignmentMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ProjectAssignmentMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ProjectAssignmentMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ProjectAssignmentMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ProjectAssignmentMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ProjectAssignmentMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ProjectAssignmentMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ProjectAssignmentMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ProjectAssignmentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the ProjectAssignmentMutation builder.
func (m *ProjectAssignmentMutation) Where(ps ...predicate.ProjectAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectAssignment).
func (m *ProjectAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, projectassignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projectassignment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectassignment.FieldCreatedAt:
		return m.CreatedAt()
	case projectassignment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectassignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectassignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectAssignmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectAssignmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectAssignmentMutation) ResetField(name string) error {
	switch name {
	case projectassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectassignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, projectassignment.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, projectassignment.EdgeProject)
	}
	if m.role != nil {
		edges = append(edges, projectassignment.EdgeRole)
	}
	if m.created_by != nil {
		edges = append(edges, projectassignment.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, projectassignment.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case projectassignment.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectassignment.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case projectassignment.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case projectassignment.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, projectassignment.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, projectassignment.EdgeProject)
	}
	if m.clearedrole {
		edges = append(edges, projectassignment.EdgeRole)
	}
	if m.clearedcreated_by {
		edges = append(edges, projectassignment.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, projectassignment.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case projectassignment.EdgeUser:
		return m.cleareduser
	case projectassignment.EdgeProject:
		return m.clearedproject
	case projectassignment.EdgeRole:
		return m.clearedrole
	case projectassignment.EdgeCreatedBy:
		return m.clearedcreated_by
	case projectassignment.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case projectassignment.EdgeUser:
		m.ClearUser()
		return nil
	case projectassignment.EdgeProject:
		m.ClearProject()
		return nil
	case projectassignment.EdgeRole:
		m.ClearRole()
		return nil
	case projectassignment.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case projectassignment.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ProjectAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case projectassignment.EdgeUser:
		m.ResetUser()
		return nil
	case projectassignment.EdgeProject:
		m.ResetProject()
		return nil
	case projectassignment.EdgeRole:
		m.ResetRole()
		return nil
	case projectassignment.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case projectassignment.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ProjectAssignment edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	key                       *string
	description               *string
	clearedFields             map[string]struct{}
	users                     map[uuid.UUID]struct{}
	removedusers              map[uuid.UUID]struct{}
	clearedusers              bool
	projectAssignments        map[uuid.UUID]struct{}
	removedprojectAssignments map[uuid.UUID]struct{}
	clearedprojectAssignments bool
	done                      bool
	oldValue                  func(context.Context) (*Role, error)
	predicates                []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "key" field.
func (m *RoleMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *RoleMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *RoleMutation) ResetKey() {
	m.key = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddProjectAssignmentIDs adds the "projectAssignments" edge to the ProjectAssignment entity by ids.
func (m *RoleMutation) AddProjectAssignmentIDs(ids ...uuid.UUID) {
	if m.projectAssignments == nil {
		m.projectAssignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.projectAssignments[ids[i]] = struct{}{}
	}
}

// ClearProjectAssignments clears the "projectAssignments" edge to the ProjectAssignment entity.
func (m *RoleMutation) ClearProjectAssignments() {
	m.clearedprojectAssignments = true
}

// ProjectAssignmentsCleared reports if the "projectAssignments" edge to the ProjectAssignment entity was cleared.
func (m *RoleMutation) ProjectAssignmentsCleared() bool {
	return m.clearedprojectAssignments
}

// RemoveProjectAssignmentIDs removes the "projectAssignments" edge to the ProjectAssignment entity by IDs.
func (m *RoleMutation) RemoveProjectAssignmentIDs(ids ...uuid.UUID) {
	if m.removedprojectAssignments == nil {
		m.removedprojectAssignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.projectAssignments, ids[i])
		m.removedprojectAssignments[ids[i]] = struct{}{}
	}
}

// RemovedProjectAssignments returns the removed IDs of the "projectAssignments" edge to the ProjectAssignment entity.
func (m *RoleMutation) RemovedProjectAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedprojectAssignments {
		ids = append(ids, id)
	}
	return
}

// ProjectAssignmentsIDs returns the "projectAssignments" edge IDs in the mutation.
func (m *RoleMutation) ProjectAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.projectAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetProjectAssignments resets all changes to the "projectAssignments" edge.
func (m *RoleMutation) ResetProjectAssignments() {
	m.projectAssignments = nil
	m.clearedprojectAssignments = false
	m.removedprojectAssignments = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, role.FieldKey)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldKey:
		return m.Key()
	case role.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldKey:
		return m.OldKey(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldKey:
		m.ResetKey()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.projectAssignments != nil {
		edges = append(edges, role.EdgeProjectAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeProjectAssignments:
		ids := make([]ent.Value, 0, len(m.projectAssignments))
		for id := range m.projectAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removedprojectAssignments != nil {
		edges = append(edges, role.EdgeProjectAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeProjectAssignments:
		ids := make([]ent.Value, 0, len(m.removedprojectAssignments))
		for id := range m.removedprojectAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedprojectAssignments {
		edges = append(edges, role.EdgeProjectAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgeProjectAssignments:
		return m.clearedprojectAssignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgeProjectAssignments:
		m.ResetProjectAssignments()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// TimeOffsetMutation represents an operation that mutates the TimeOffset nodes in the graph.
type TimeOffsetMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	server_time       *time.Time
	camera_time       *time.Time
	offset_seconds    *int
	addoffset_seconds *int
	clearedFields     map[string]struct{}
	camera            *uuid.UUID
	clearedcamera     bool
	created_by        *uuid.UUID
	clearedcreated_by bool
	updated_by        *uuid.UUID
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*TimeOffset, error)
	predicates        []predicate.TimeOffset
}

var _ ent.Mutation = (*TimeOffsetMutation)(nil)

// timeoffsetOption allows management of the mutation configuration using functional options.
type timeoffsetOption func(*TimeOffsetMutation)

// newTimeOffsetMutation creates new mutation for the TimeOffset entity.
func newTimeOffsetMutation(c config, op Op, opts ...timeoffsetOption) *TimeOffsetMutation {
	m := &TimeOffsetMutation{
		config:        c,
		op:            op,
		typ:           TypeTimeOffset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeOffsetID sets the ID field of the mutation.
func withTimeOffsetID(id uuid.UUID) timeoffsetOption {
	return func(m *TimeOffsetMutation) {
		var (
			err   error
			once  sync.Once
			value *TimeOffset
		)
		m.oldValue = func(ctx context.Context) (*TimeOffset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimeOffset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimeOffset sets the old TimeOffset of the mutation.
func withTimeOffset(node *TimeOffset) timeoffsetOption {
	return func(m *TimeOffsetMutation) {
		m.oldValue = func(context.Context) (*TimeOffset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeOffsetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeOffsetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TimeOffset entities.
func (m *TimeOffsetMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeOffsetMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeOffsetMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimeOffset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TimeOffsetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimeOffsetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimeOffsetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TimeOffsetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TimeOffsetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TimeOffsetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetServerTime sets the "server_time" field.
func (m *TimeOffsetMutation) SetServerTime(t time.Time) {
	m.server_time = &t
}

// ServerTime returns the value of the "server_time" field in the mutation.
func (m *TimeOffsetMutation) ServerTime() (r time.Time, exists bool) {
	v := m.server_time
	if v == nil {
		return
	}
	return *v, true
}

// OldServerTime returns the old "server_time" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldServerTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerTime: %w", err)
	}
	return oldValue.ServerTime, nil
}

// ResetServerTime resets all changes to the "server_time" field.
func (m *TimeOffsetMutation) ResetServerTime() {
	m.server_time = nil
}

// SetCameraTime sets the "camera_time" field.
func (m *TimeOffsetMutation) SetCameraTime(t time.Time) {
	m.camera_time = &t
}

// CameraTime returns the value of the "camera_time" field in the mutation.
func (m *TimeOffsetMutation) CameraTime() (r time.Time, exists bool) {
	v := m.camera_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCameraTime returns the old "camera_time" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldCameraTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCameraTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCameraTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCameraTime: %w", err)
	}
	return oldValue.CameraTime, nil
}

// ResetCameraTime resets all changes to the "camera_time" field.
func (m *TimeOffsetMutation) ResetCameraTime() {
	m.camera_time = nil
}

// SetOffsetSeconds sets the "offset_seconds" field.
func (m *TimeOffsetMutation) SetOffsetSeconds(i int) {
	m.offset_seconds = &i
	m.addoffset_seconds = nil
}

// OffsetSeconds returns the value of the "offset_seconds" field in the mutation.
func (m *TimeOffsetMutation) OffsetSeconds() (r int, exists bool) {
	v := m.offset_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldOffsetSeconds returns the old "offset_seconds" field's value of the TimeOffset entity.
// If the TimeOffset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffsetMutation) OldOffsetSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOffsetSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOffsetSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOffsetSeconds: %w", err)
	}
	return oldValue.OffsetSeconds, nil
}

// AddOffsetSeconds adds i to the "offset_seconds" field.
func (m *TimeOffsetMutation) AddOffsetSeconds(i int) {
	if m.addoffset_seconds != nil {
		*m.addoffset_seconds += i
	} else {
		m.addoffset_seconds = &i
	}
}

// AddedOffsetSeconds returns the value that was added to the "offset_seconds" field in this mutation.
func (m *TimeOffsetMutation) AddedOffsetSeconds() (r int, exists bool) {
	v := m.addoffset_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetOffsetSeconds resets all changes to the "offset_seconds" field.
func (m *TimeOffsetMutation) ResetOffsetSeconds() {
	m.offset_seconds = nil
	m.addoffset_seconds = nil
}

// SetCameraID sets the "camera" edge to the Camera entity by id.
func (m *TimeOffsetMutation) SetCameraID(id uuid.UUID) {
	m.camera = &id
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *TimeOffsetMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *TimeOffsetMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraID returns the "camera" edge ID in the mutation.
func (m *TimeOffsetMutation) CameraID() (id uuid.UUID, exists bool) {
	if m.camera != nil {
		return *m.camera, true
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *TimeOffsetMutation) CameraIDs() (ids []uuid.UUID) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *TimeOffsetMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *TimeOffsetMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *TimeOffsetMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *TimeOffsetMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *TimeOffsetMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *TimeOffsetMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *TimeOffsetMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *TimeOffsetMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *TimeOffsetMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *TimeOffsetMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *TimeOffsetMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *TimeOffsetMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *TimeOffsetMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the TimeOffsetMutation builder.
func (m *TimeOffsetMutation) Where(ps ...predicate.TimeOffset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimeOffsetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimeOffsetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimeOffset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimeOffsetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimeOffsetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimeOffset).
func (m *TimeOffsetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeOffsetMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, timeoffset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, timeoffset.FieldUpdatedAt)
	}
	if m.server_time != nil {
		fields = append(fields, timeoffset.FieldServerTime)
	}
	if m.camera_time != nil {
		fields = append(fields, timeoffset.FieldCameraTime)
	}
	if m.offset_seconds != nil {
		fields = append(fields, timeoffset.FieldOffsetSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeOffsetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timeoffset.FieldCreatedAt:
		return m.CreatedAt()
	case timeoffset.FieldUpdatedAt:
		return m.UpdatedAt()
	case timeoffset.FieldServerTime:
		return m.ServerTime()
	case timeoffset.FieldCameraTime:
		return m.CameraTime()
	case timeoffset.FieldOffsetSeconds:
		return m.OffsetSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeOffsetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timeoffset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case timeoffset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case timeoffset.FieldServerTime:
		return m.OldServerTime(ctx)
	case timeoffset.FieldCameraTime:
		return m.OldCameraTime(ctx)
	case timeoffset.FieldOffsetSeconds:
		return m.OldOffsetSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown TimeOffset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffsetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timeoffset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case timeoffset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case timeoffset.FieldServerTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerTime(v)
		return nil
	case timeoffset.FieldCameraTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCameraTime(v)
		return nil
	case timeoffset.FieldOffsetSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOffsetSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeOffsetMutation) AddedFields() []string {
	var fields []string
	if m.addoffset_seconds != nil {
		fields = append(fields, timeoffset.FieldOffsetSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeOffsetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timeoffset.FieldOffsetSeconds:
		return m.AddedOffsetSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffsetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timeoffset.FieldOffsetSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOffsetSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeOffsetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeOffsetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeOffsetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TimeOffset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeOffsetMutation) ResetField(name string) error {
	switch name {
	case timeoffset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case timeoffset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case timeoffset.FieldServerTime:
		m.ResetServerTime()
		return nil
	case timeoffset.FieldCameraTime:
		m.ResetCameraTime()
		return nil
	case timeoffset.FieldOffsetSeconds:
		m.ResetOffsetSeconds()
		return nil
	}
	return fmt.Errorf("unknown TimeOffset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeOffsetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.camera != nil {
		edges = append(edges, timeoffset.EdgeCamera)
	}
	if m.created_by != nil {
		edges = append(edges, timeoffset.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, timeoffset.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeOffsetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timeoffset.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	case timeoffset.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case timeoffset.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeOffsetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeOffsetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeOffsetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcamera {
		edges = append(edges, timeoffset.EdgeCamera)
	}
	if m.clearedcreated_by {
		edges = append(edges, timeoffset.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, timeoffset.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeOffsetMutation) EdgeCleared(name string) bool {
	switch name {
	case timeoffset.EdgeCamera:
		return m.clearedcamera
	case timeoffset.EdgeCreatedBy:
		return m.clearedcreated_by
	case timeoffset.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeOffsetMutation) ClearEdge(name string) error {
	switch name {
	case timeoffset.EdgeCamera:
		m.ClearCamera()
		return nil
	case timeoffset.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case timeoffset.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown TimeOffset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeOffsetMutation) ResetEdge(name string) error {
	switch name {
	case timeoffset.EdgeCamera:
		m.ResetCamera()
		return nil
	case timeoffset.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case timeoffset.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown TimeOffset edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	first_name                *string
	last_name                 *string
	email                     *string
	copyright_tag             *string
	email_validated           *bool
	validation_key            *uuid.UUID
	validation_sent_at        *time.Time
	password                  *[]byte
	password_reset_key        *uuid.UUID
	password_reset_at         *time.Time
	active                    *bool
	clearedFields             map[string]struct{}
	role                      *uuid.UUID
	clearedrole               bool
	projectAssignments        map[uuid.UUID]struct{}
	removedprojectAssignments map[uuid.UUID]struct{}
	clearedprojectAssignments bool
	images                    map[uuid.UUID]struct{}
	removedimages             map[uuid.UUID]struct{}
	clearedimages             bool
	cameras                   map[uuid.UUID]struct{}
	removedcameras            map[uuid.UUID]struct{}
	clearedcameras            bool
	created_users             map[uuid.UUID]struct{}
	removedcreated_users      map[uuid.UUID]struct{}
	clearedcreated_users      bool
	created_by                *uuid.UUID
	clearedcreated_by         bool
	modified_users            map[uuid.UUID]struct{}
	removedmodified_users     map[uuid.UUID]struct{}
	clearedmodified_users     bool
	updated_by                *uuid.UUID
	clearedupdated_by         bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetCopyrightTag sets the "copyright_tag" field.
func (m *UserMutation) SetCopyrightTag(s string) {
	m.copyright_tag = &s
}

// CopyrightTag returns the value of the "copyright_tag" field in the mutation.
func (m *UserMutation) CopyrightTag() (r string, exists bool) {
	v := m.copyright_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyrightTag returns the old "copyright_tag" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCopyrightTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyrightTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyrightTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyrightTag: %w", err)
	}
	return oldValue.CopyrightTag, nil
}

// ResetCopyrightTag resets all changes to the "copyright_tag" field.
func (m *UserMutation) ResetCopyrightTag() {
	m.copyright_tag = nil
}

// SetEmailValidated sets the "email_validated" field.
func (m *UserMutation) SetEmailValidated(b bool) {
	m.email_validated = &b
}

// EmailValidated returns the value of the "email_validated" field in the mutation.
func (m *UserMutation) EmailValidated() (r bool, exists bool) {
	v := m.email_validated
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailValidated returns the old "email_validated" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailValidated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailValidated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailValidated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailValidated: %w", err)
	}
	return oldValue.EmailValidated, nil
}

// ResetEmailValidated resets all changes to the "email_validated" field.
func (m *UserMutation) ResetEmailValidated() {
	m.email_validated = nil
}

// SetValidationKey sets the "validation_key" field.
func (m *UserMutation) SetValidationKey(u uuid.UUID) {
	m.validation_key = &u
}

// ValidationKey returns the value of the "validation_key" field in the mutation.
func (m *UserMutation) ValidationKey() (r uuid.UUID, exists bool) {
	v := m.validation_key
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationKey returns the old "validation_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldValidationKey(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationKey: %w", err)
	}
	return oldValue.ValidationKey, nil
}

// ResetValidationKey resets all changes to the "validation_key" field.
func (m *UserMutation) ResetValidationKey() {
	m.validation_key = nil
}

// SetValidationSentAt sets the "validation_sent_at" field.
func (m *UserMutation) SetValidationSentAt(t time.Time) {
	m.validation_sent_at = &t
}

// ValidationSentAt returns the value of the "validation_sent_at" field in the mutation.
func (m *UserMutation) ValidationSentAt() (r time.Time, exists bool) {
	v := m.validation_sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationSentAt returns the old "validation_sent_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldValidationSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationSentAt: %w", err)
	}
	return oldValue.ValidationSentAt, nil
}

// ResetValidationSentAt resets all changes to the "validation_sent_at" field.
func (m *UserMutation) ResetValidationSentAt() {
	m.validation_sent_at = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetPasswordResetKey sets the "password_reset_key" field.
func (m *UserMutation) SetPasswordResetKey(u uuid.UUID) {
	m.password_reset_key = &u
}

// PasswordResetKey returns the value of the "password_reset_key" field in the mutation.
func (m *UserMutation) PasswordResetKey() (r uuid.UUID, exists bool) {
	v := m.password_reset_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordResetKey returns the old "password_reset_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordResetKey(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordResetKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordResetKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordResetKey: %w", err)
	}
	return oldValue.PasswordResetKey, nil
}

// ResetPasswordResetKey resets all changes to the "password_reset_key" field.
func (m *UserMutation) ResetPasswordResetKey() {
	m.password_reset_key = nil
}

// SetPasswordResetAt sets the "password_reset_at" field.
func (m *UserMutation) SetPasswordResetAt(t time.Time) {
	m.password_reset_at = &t
}

// PasswordResetAt returns the value of the "password_reset_at" field in the mutation.
func (m *UserMutation) PasswordResetAt() (r time.Time, exists bool) {
	v := m.password_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordResetAt returns the old "password_reset_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordResetAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordResetAt: %w", err)
	}
	return oldValue.PasswordResetAt, nil
}

// ResetPasswordResetAt resets all changes to the "password_reset_at" field.
func (m *UserMutation) ResetPasswordResetAt() {
	m.password_reset_at = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *UserMutation) SetRoleID(id uuid.UUID) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *UserMutation) RoleID() (id uuid.UUID, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// AddProjectAssignmentIDs adds the "projectAssignments" edge to the ProjectAssignment entity by ids.
func (m *UserMutation) AddProjectAssignmentIDs(ids ...uuid.UUID) {
	if m.projectAssignments == nil {
		m.projectAssignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.projectAssignments[ids[i]] = struct{}{}
	}
}

// ClearProjectAssignments clears the "projectAssignments" edge to the ProjectAssignment entity.
func (m *UserMutation) ClearProjectAssignments() {
	m.clearedprojectAssignments = true
}

// ProjectAssignmentsCleared reports if the "projectAssignments" edge to the ProjectAssignment entity was cleared.
func (m *UserMutation) ProjectAssignmentsCleared() bool {
	return m.clearedprojectAssignments
}

// RemoveProjectAssignmentIDs removes the "projectAssignments" edge to the ProjectAssignment entity by IDs.
func (m *UserMutation) RemoveProjectAssignmentIDs(ids ...uuid.UUID) {
	if m.removedprojectAssignments == nil {
		m.removedprojectAssignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.projectAssignments, ids[i])
		m.removedprojectAssignments[ids[i]] = struct{}{}
	}
}

// RemovedProjectAssignments returns the removed IDs of the "projectAssignments" edge to the ProjectAssignment entity.
func (m *UserMutation) RemovedProjectAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedprojectAssignments {
		ids = append(ids, id)
	}
	return
}

// ProjectAssignmentsIDs returns the "projectAssignments" edge IDs in the mutation.
func (m *UserMutation) ProjectAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.projectAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetProjectAssignments resets all changes to the "projectAssignments" edge.
func (m *UserMutation) ResetProjectAssignments() {
	m.projectAssignments = nil
	m.clearedprojectAssignments = false
	m.removedprojectAssignments = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *UserMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *UserMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *UserMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *UserMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *UserMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *UserMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *UserMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddCameraIDs adds the "cameras" edge to the Camera entity by ids.
func (m *UserMutation) AddCameraIDs(ids ...uuid.UUID) {
	if m.cameras == nil {
		m.cameras = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cameras[ids[i]] = struct{}{}
	}
}

// ClearCameras clears the "cameras" edge to the Camera entity.
func (m *UserMutation) ClearCameras() {
	m.clearedcameras = true
}

// CamerasCleared reports if the "cameras" edge to the Camera entity was cleared.
func (m *UserMutation) CamerasCleared() bool {
	return m.clearedcameras
}

// RemoveCameraIDs removes the "cameras" edge to the Camera entity by IDs.
func (m *UserMutation) RemoveCameraIDs(ids ...uuid.UUID) {
	if m.removedcameras == nil {
		m.removedcameras = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cameras, ids[i])
		m.removedcameras[ids[i]] = struct{}{}
	}
}

// RemovedCameras returns the removed IDs of the "cameras" edge to the Camera entity.
func (m *UserMutation) RemovedCamerasIDs() (ids []uuid.UUID) {
	for id := range m.removedcameras {
		ids = append(ids, id)
	}
	return
}

// CamerasIDs returns the "cameras" edge IDs in the mutation.
func (m *UserMutation) CamerasIDs() (ids []uuid.UUID) {
	for id := range m.cameras {
		ids = append(ids, id)
	}
	return
}

// ResetCameras resets all changes to the "cameras" edge.
func (m *UserMutation) ResetCameras() {
	m.cameras = nil
	m.clearedcameras = false
	m.removedcameras = nil
}

// AddCreatedUserIDs adds the "created_users" edge to the User entity by ids.
func (m *UserMutation) AddCreatedUserIDs(ids ...uuid.UUID) {
	if m.created_users == nil {
		m.created_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_users[ids[i]] = struct{}{}
	}
}

// ClearCreatedUsers clears the "created_users" edge to the User entity.
func (m *UserMutation) ClearCreatedUsers() {
	m.clearedcreated_users = true
}

// CreatedUsersCleared reports if the "created_users" edge to the User entity was cleared.
func (m *UserMutation) CreatedUsersCleared() bool {
	return m.clearedcreated_users
}

// RemoveCreatedUserIDs removes the "created_users" edge to the User entity by IDs.
func (m *UserMutation) RemoveCreatedUserIDs(ids ...uuid.UUID) {
	if m.removedcreated_users == nil {
		m.removedcreated_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_users, ids[i])
		m.removedcreated_users[ids[i]] = struct{}{}
	}
}

// RemovedCreatedUsers returns the removed IDs of the "created_users" edge to the User entity.
func (m *UserMutation) RemovedCreatedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_users {
		ids = append(ids, id)
	}
	return
}

// CreatedUsersIDs returns the "created_users" edge IDs in the mutation.
func (m *UserMutation) CreatedUsersIDs() (ids []uuid.UUID) {
	for id := range m.created_users {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedUsers resets all changes to the "created_users" edge.
func (m *UserMutation) ResetCreatedUsers() {
	m.created_users = nil
	m.clearedcreated_users = false
	m.removedcreated_users = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *UserMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *UserMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *UserMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *UserMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddModifiedUserIDs adds the "modified_users" edge to the User entity by ids.
func (m *UserMutation) AddModifiedUserIDs(ids ...uuid.UUID) {
	if m.modified_users == nil {
		m.modified_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.modified_users[ids[i]] = struct{}{}
	}
}

// ClearModifiedUsers clears the "modified_users" edge to the User entity.
func (m *UserMutation) ClearModifiedUsers() {
	m.clearedmodified_users = true
}

// ModifiedUsersCleared reports if the "modified_users" edge to the User entity was cleared.
func (m *UserMutation) ModifiedUsersCleared() bool {
	return m.clearedmodified_users
}

// RemoveModifiedUserIDs removes the "modified_users" edge to the User entity by IDs.
func (m *UserMutation) RemoveModifiedUserIDs(ids ...uuid.UUID) {
	if m.removedmodified_users == nil {
		m.removedmodified_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.modified_users, ids[i])
		m.removedmodified_users[ids[i]] = struct{}{}
	}
}

// RemovedModifiedUsers returns the removed IDs of the "modified_users" edge to the User entity.
func (m *UserMutation) RemovedModifiedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedmodified_users {
		ids = append(ids, id)
	}
	return
}

// ModifiedUsersIDs returns the "modified_users" edge IDs in the mutation.
func (m *UserMutation) ModifiedUsersIDs() (ids []uuid.UUID) {
	for id := range m.modified_users {
		ids = append(ids, id)
	}
	return
}

// ResetModifiedUsers resets all changes to the "modified_users" edge.
func (m *UserMutation) ResetModifiedUsers() {
	m.modified_users = nil
	m.clearedmodified_users = false
	m.removedmodified_users = nil
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *UserMutation) SetUpdatedByID(id uuid.UUID) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *UserMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *UserMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *UserMutation) UpdatedByID() (id uuid.UUID, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UpdatedByIDs() (ids []uuid.UUID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.copyright_tag != nil {
		fields = append(fields, user.FieldCopyrightTag)
	}
	if m.email_validated != nil {
		fields = append(fields, user.FieldEmailValidated)
	}
	if m.validation_key != nil {
		fields = append(fields, user.FieldValidationKey)
	}
	if m.validation_sent_at != nil {
		fields = append(fields, user.FieldValidationSentAt)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.password_reset_key != nil {
		fields = append(fields, user.FieldPasswordResetKey)
	}
	if m.password_reset_at != nil {
		fields = append(fields, user.FieldPasswordResetAt)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldCopyrightTag:
		return m.CopyrightTag()
	case user.FieldEmailValidated:
		return m.EmailValidated()
	case user.FieldValidationKey:
		return m.ValidationKey()
	case user.FieldValidationSentAt:
		return m.ValidationSentAt()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPasswordResetKey:
		return m.PasswordResetKey()
	case user.FieldPasswordResetAt:
		return m.PasswordResetAt()
	case user.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldCopyrightTag:
		return m.OldCopyrightTag(ctx)
	case user.FieldEmailValidated:
		return m.OldEmailValidated(ctx)
	case user.FieldValidationKey:
		return m.OldValidationKey(ctx)
	case user.FieldValidationSentAt:
		return m.OldValidationSentAt(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPasswordResetKey:
		return m.OldPasswordResetKey(ctx)
	case user.FieldPasswordResetAt:
		return m.OldPasswordResetAt(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldCopyrightTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyrightTag(v)
		return nil
	case user.FieldEmailValidated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailValidated(v)
		return nil
	case user.FieldValidationKey:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationKey(v)
		return nil
	case user.FieldValidationSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationSentAt(v)
		return nil
	case user.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPasswordResetKey:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordResetKey(v)
		return nil
	case user.FieldPasswordResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordResetAt(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldCopyrightTag:
		m.ResetCopyrightTag()
		return nil
	case user.FieldEmailValidated:
		m.ResetEmailValidated()
		return nil
	case user.FieldValidationKey:
		m.ResetValidationKey()
		return nil
	case user.FieldValidationSentAt:
		m.ResetValidationSentAt()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPasswordResetKey:
		m.ResetPasswordResetKey()
		return nil
	case user.FieldPasswordResetAt:
		m.ResetPasswordResetAt()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.role != nil {
		edges = append(edges, user.EdgeRole)
	}
	if m.projectAssignments != nil {
		edges = append(edges, user.EdgeProjectAssignments)
	}
	if m.images != nil {
		edges = append(edges, user.EdgeImages)
	}
	if m.cameras != nil {
		edges = append(edges, user.EdgeCameras)
	}
	if m.created_users != nil {
		edges = append(edges, user.EdgeCreatedUsers)
	}
	if m.created_by != nil {
		edges = append(edges, user.EdgeCreatedBy)
	}
	if m.modified_users != nil {
		edges = append(edges, user.EdgeModifiedUsers)
	}
	if m.updated_by != nil {
		edges = append(edges, user.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeProjectAssignments:
		ids := make([]ent.Value, 0, len(m.projectAssignments))
		for id := range m.projectAssignments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCameras:
		ids := make([]ent.Value, 0, len(m.cameras))
		for id := range m.cameras {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUsers:
		ids := make([]ent.Value, 0, len(m.created_users))
		for id := range m.created_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeModifiedUsers:
		ids := make([]ent.Value, 0, len(m.modified_users))
		for id := range m.modified_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedprojectAssignments != nil {
		edges = append(edges, user.EdgeProjectAssignments)
	}
	if m.removedimages != nil {
		edges = append(edges, user.EdgeImages)
	}
	if m.removedcameras != nil {
		edges = append(edges, user.EdgeCameras)
	}
	if m.removedcreated_users != nil {
		edges = append(edges, user.EdgeCreatedUsers)
	}
	if m.removedmodified_users != nil {
		edges = append(edges, user.EdgeModifiedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjectAssignments:
		ids := make([]ent.Value, 0, len(m.removedprojectAssignments))
		for id := range m.removedprojectAssignments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCameras:
		ids := make([]ent.Value, 0, len(m.removedcameras))
		for id := range m.removedcameras {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUsers:
		ids := make([]ent.Value, 0, len(m.removedcreated_users))
		for id := range m.removedcreated_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModifiedUsers:
		ids := make([]ent.Value, 0, len(m.removedmodified_users))
		for id := range m.removedmodified_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedrole {
		edges = append(edges, user.EdgeRole)
	}
	if m.clearedprojectAssignments {
		edges = append(edges, user.EdgeProjectAssignments)
	}
	if m.clearedimages {
		edges = append(edges, user.EdgeImages)
	}
	if m.clearedcameras {
		edges = append(edges, user.EdgeCameras)
	}
	if m.clearedcreated_users {
		edges = append(edges, user.EdgeCreatedUsers)
	}
	if m.clearedcreated_by {
		edges = append(edges, user.EdgeCreatedBy)
	}
	if m.clearedmodified_users {
		edges = append(edges, user.EdgeModifiedUsers)
	}
	if m.clearedupdated_by {
		edges = append(edges, user.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRole:
		return m.clearedrole
	case user.EdgeProjectAssignments:
		return m.clearedprojectAssignments
	case user.EdgeImages:
		return m.clearedimages
	case user.EdgeCameras:
		return m.clearedcameras
	case user.EdgeCreatedUsers:
		return m.clearedcreated_users
	case user.EdgeCreatedBy:
		return m.clearedcreated_by
	case user.EdgeModifiedUsers:
		return m.clearedmodified_users
	case user.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ClearRole()
		return nil
	case user.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case user.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ResetRole()
		return nil
	case user.EdgeProjectAssignments:
		m.ResetProjectAssignments()
		return nil
	case user.EdgeImages:
		m.ResetImages()
		return nil
	case user.EdgeCameras:
		m.ResetCameras()
		return nil
	case user.EdgeCreatedUsers:
		m.ResetCreatedUsers()
		return nil
	case user.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.EdgeModifiedUsers:
		m.ResetModifiedUsers()
		return nil
	case user.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
